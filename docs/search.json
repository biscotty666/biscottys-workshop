[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "biscotty's Workshop",
    "section": "",
    "text": "For the love of learning\n\nI’ll write some intro material here. I’ll write some intro material here. I’ll write some intro material here.\nCheck out the current workshop.\nThanks to (Shanny-Csik 2022)\n\n\n\n Back to topReferences\n\nShanny-Csik, Samantha. 2022. “Adding a Blog to Your Existing Quarto Website.” October 24, 2022. https://samanthacsik.github.io/posts/2022-10-24-quarto-blogs/."
  },
  {
    "objectID": "data-science.html",
    "href": "data-science.html",
    "title": "Data Science",
    "section": "",
    "text": "Trail Mapping with Python\n\n\n\n\n\n\nGIS\n\n\nPython\n\n\nData Science\n\n\n\nUsing your GPX data with geopandas\n\n\n\n\n\nFeb 28, 2024\n\n\nBrian Carey\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Home",
      "Data Science"
    ]
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "Posts",
    "section": "",
    "text": "Obsidian and Jupyter Notebooks\n\n\n\n\n\n\nObsidian\n\n\nPython\n\n\nData Science\n\n\n\nPersonal Knowledge Management for Data Science\n\n\n\n\n\nMar 20, 2024\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nTrail Mapping with Python\n\n\n\n\n\n\nGIS\n\n\nPython\n\n\nData Science\n\n\n\nUsing your GPX data with geopandas\n\n\n\n\n\nFeb 28, 2024\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nDataviewJS: A Gentle Introduction Part 2\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nDataviewJS\n\n\n\nSelecting Files, Working with Dates\n\n\n\n\n\nFeb 28, 2024\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nGit and GitHub for Obsidian Users\n\n\n\n\n\n\nObsidian\n\n\nLinux\n\n\n\nAnd why you probably shouldn’t be using it\n\n\n\n\n\nJan 19, 2024\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nSummarizing Information with DataviewJS\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nPresenting and analyzing information in Obsidian\n\n\n\n\n\nOct 16, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive Tables with DataviewJS\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nDataviewJS\n\n\n\nSelecting Files, Working with Dates\n\n\n\n\n\nOct 14, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nDataviewJS: A Gentle Introduction\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nDataviewJS\n\n\n\nFor Obsidian users who are not programmers\n\n\n\n\n\nOct 11, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nObsidian: Freeing Your Thinking Workflow\n\n\n\n\n\n\nObsidian\n\n\nPKM\n\n\n\nA video showing how to use the information-focused Freeing Your Thinking paradigm.\n\n\n\n\n\nSep 21, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nObsidian Metadata Menu Plugin\n\n\n\n\n\n\nObsidian\n\n\n\nSupercharge your management of properties and in-line Dataview fields\n\n\n\n\n\nSep 6, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nObsidian Bookmarks\n\n\n\n\n\n\nObsidian\n\n\n\nBookmarks are the key to effectively using obsidian as a non-relational database. \n\n\n\n\n\nSep 5, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nObsidian: The mechanics of Graph View\n\n\n\n\n\n\nObsidian\n\n\n\nVideo - Working with Graph View to explore your information network.\n\n\n\n\n\nAug 31, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nObsidian Basics - Headers\n\n\n\n\n\n\nObsidian\n\n\n\nHeaders add more than visual appeal. They are important for structuring your document and enabling atomic embeds.\n\n\n\n\n\nAug 27, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nWhat does it mean that is a NoSQL Database?\n\n\n\n\n\n\nObsidian\n\n\n\nObsidian is a non-relational database. This article explains this and the significance of the fact.\n\n\n\n\n\nAug 24, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nObsidian: Stop Wasting Time With Directories and Filenames\n\n\n\n\n\n\nObsidian\n\n\nPKM\n\n\n\nFreeing Your Thiking Part 1 introduces the idea of of working with Obsidian as a database. This part covers capture and retrieval of information useing Unique Notes, Search and Bookmarks.\n\n\n\n\n\nAug 24, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nObsidian: Meaningless Names, No Directories, Now What?\n\n\n\n\n\n\nObsidian\n\n\nPKM\n\n\n\nFreeing Your Thiking Part 2 discusses the use of Graph View and Bookmarks to discover and organize information in your vault\n\n\n\n\n\nAug 24, 2023\n\n\nBrian Carey\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "blogs/obsidian/freeing-your-thinking-part-2/index.html",
    "href": "blogs/obsidian/freeing-your-thinking-part-2/index.html",
    "title": "Obsidian: Meaningless Names, No Directories, Now What?",
    "section": "",
    "text": "Let me state my goal plainly: I want to be able to find all of my relevant information on a given topic and synthesize my understanding of that topic in a document or drawing, maybe for personal use, maybe for sharing or publishing.\nFor this purpose, a primary tool I use is Graph View. Yes, Graph View. And, in the process, I rehabilitate file names as a Valuable Thing.\nTo explain why Graph View is the best tool for this type of work, I need to re-visit the idea of Obsidian as a database.\n\n\n\nThere are two different types of databases. Most common are relational databases, or SQL databases. These are table-based (think spreadsheets) and depend on pre-defining relationships and hierarchies between tables. But Obsidian is clearly not an SQL database, since it has no underlying table structure. It is, in fact, a NoSQL database, aka non-relational database.\nThe Substack Helper thought my detailed explanation too long for this article, so I moved most of the discussion to Part 3. I encourage you to read that before continuing, but it is not actually necessary\nTLDR: Since Obsidian is a non-relational database, I use it as such.\nDatabases are queried for information. We have search filters that we can use for that, and which can be applied to both graphs and searches. We don’t get information from a database by opening a table or navigating to a record in the database. That is effectively the approach you take if you open a note to get its information.\n\n\n\nIn the first part, I talked about a workflow which created files with unique, meaningless names. If you have tried the proposed workflow, however, you will already have a number of meaningfully named notes in your vault. Every note has a topic:: field, which is a link or links, and those linked files have the name of the topic. The file may or may not actually exist. For Graph View, it doesn’t matter. You may have added links to the related:: field as well, thereby creating more meaningfully name notes. In the course of processing your atomic notes, you have given them meaningful names. Now that we are getting visual, meaningful names are useful. All your MOCs, existing or not, are already meaningfully named.\n\n\n\nThe most frequent type of comment I see about Graph View is along the lines of “it’s pretty to look at, but when you have a lot of notes it just becomes a useless, chaotic mess”. That’s like complaining that a dataview query listing every note in your vault is just too overwhelming to deal with. Well, yeah! Other than when you are enjoying the eye candy, you would never look at an unfiltered graph any more than use an unfiltered query.\nAs described in part one, filters can be just as sophisticated as dataview queries, and graph filters works exactly like filters do in Search. So, if I want to explore the information I have relating to a topic, I start by typing the topic in the graph filter. Now I can see all the files containing the words of the topic, any of which are potentially related. Some may already be linked, but if I show orphans, I can see more files which could or should be linked to the topic. With Hover Editor, it’s easy to look at each document’s contents and decided whether they should be related or not without opening the file. And if they should be, I can add the link directly in Hover Editor. I never need to actually open any files. And I can add or remove words to my filter to find information that is related but perhaps worded differently. Finally, I can bookmark the graph and easily return to it later to discover new, related information using the same filters.\nAssuming I have already created notes on a topic, I will already have a map of content named after the topic. If the file doesn’t yet exist, I can click on the node to create it and manually add the standard template. This Map of Content will already have a list of related files and a graph view which shows them, both accessible in the right sidebar. Now, as I look at potentially relevant notes in Graph View and add links to the topic:: field, my MOC is accumulating the links, and a neural network is developing.\nThe right sidebar version of the graph provides an additional feature, the ability to adjust “levels”. This allows you to not only see notes linked to the current note, but also notes that are linked to those notes. In a family tree this is kind of like cousins, cousins once-removed, and so forth. Some of these more distant relations should/could be directly linked to the main topic.\nAnd remember, thanks to Hover Editor, I never have to open a file except when I create one.\n\n\n\nHonestly, sometimes my brain just wants a list of things without extra visual stimulation. With Bookmarks, I can build knowledge trees for a topic, basically like a rich outline.\nI create a virtual (bookmark) directory for the topic. As I work with my information, I bookmark interesting blocks with information (I do not bookmark files, just information). These could be sections, paragraphs, images, embedded PDFs…anything really. Bookmarks can be named as well. For complex topics, I can create subdirectories as appropriate.\nThis results in what is essentially a detailed outline of all my information on a topic. A virtual Map of Content, if you will.",
    "crumbs": [
      "Obsidian",
      "Obsidian: Meaningless Names, No Directories, Now What?"
    ]
  },
  {
    "objectID": "blogs/obsidian/freeing-your-thinking-part-2/index.html#analyzing-and-synthesizing-information",
    "href": "blogs/obsidian/freeing-your-thinking-part-2/index.html#analyzing-and-synthesizing-information",
    "title": "Obsidian: Meaningless Names, No Directories, Now What?",
    "section": "",
    "text": "Let me state my goal plainly: I want to be able to find all of my relevant information on a given topic and synthesize my understanding of that topic in a document or drawing, maybe for personal use, maybe for sharing or publishing.\nFor this purpose, a primary tool I use is Graph View. Yes, Graph View. And, in the process, I rehabilitate file names as a Valuable Thing.\nTo explain why Graph View is the best tool for this type of work, I need to re-visit the idea of Obsidian as a database.",
    "crumbs": [
      "Obsidian",
      "Obsidian: Meaningless Names, No Directories, Now What?"
    ]
  },
  {
    "objectID": "blogs/obsidian/freeing-your-thinking-part-2/index.html#sql-and-nosql-databases",
    "href": "blogs/obsidian/freeing-your-thinking-part-2/index.html#sql-and-nosql-databases",
    "title": "Obsidian: Meaningless Names, No Directories, Now What?",
    "section": "",
    "text": "There are two different types of databases. Most common are relational databases, or SQL databases. These are table-based (think spreadsheets) and depend on pre-defining relationships and hierarchies between tables. But Obsidian is clearly not an SQL database, since it has no underlying table structure. It is, in fact, a NoSQL database, aka non-relational database.\nThe Substack Helper thought my detailed explanation too long for this article, so I moved most of the discussion to Part 3. I encourage you to read that before continuing, but it is not actually necessary\nTLDR: Since Obsidian is a non-relational database, I use it as such.\nDatabases are queried for information. We have search filters that we can use for that, and which can be applied to both graphs and searches. We don’t get information from a database by opening a table or navigating to a record in the database. That is effectively the approach you take if you open a note to get its information.",
    "crumbs": [
      "Obsidian",
      "Obsidian: Meaningless Names, No Directories, Now What?"
    ]
  },
  {
    "objectID": "blogs/obsidian/freeing-your-thinking-part-2/index.html#filenames-revisited",
    "href": "blogs/obsidian/freeing-your-thinking-part-2/index.html#filenames-revisited",
    "title": "Obsidian: Meaningless Names, No Directories, Now What?",
    "section": "",
    "text": "In the first part, I talked about a workflow which created files with unique, meaningless names. If you have tried the proposed workflow, however, you will already have a number of meaningfully named notes in your vault. Every note has a topic:: field, which is a link or links, and those linked files have the name of the topic. The file may or may not actually exist. For Graph View, it doesn’t matter. You may have added links to the related:: field as well, thereby creating more meaningfully name notes. In the course of processing your atomic notes, you have given them meaningful names. Now that we are getting visual, meaningful names are useful. All your MOCs, existing or not, are already meaningfully named.",
    "crumbs": [
      "Obsidian",
      "Obsidian: Meaningless Names, No Directories, Now What?"
    ]
  },
  {
    "objectID": "blogs/obsidian/freeing-your-thinking-part-2/index.html#graph-view",
    "href": "blogs/obsidian/freeing-your-thinking-part-2/index.html#graph-view",
    "title": "Obsidian: Meaningless Names, No Directories, Now What?",
    "section": "",
    "text": "The most frequent type of comment I see about Graph View is along the lines of “it’s pretty to look at, but when you have a lot of notes it just becomes a useless, chaotic mess”. That’s like complaining that a dataview query listing every note in your vault is just too overwhelming to deal with. Well, yeah! Other than when you are enjoying the eye candy, you would never look at an unfiltered graph any more than use an unfiltered query.\nAs described in part one, filters can be just as sophisticated as dataview queries, and graph filters works exactly like filters do in Search. So, if I want to explore the information I have relating to a topic, I start by typing the topic in the graph filter. Now I can see all the files containing the words of the topic, any of which are potentially related. Some may already be linked, but if I show orphans, I can see more files which could or should be linked to the topic. With Hover Editor, it’s easy to look at each document’s contents and decided whether they should be related or not without opening the file. And if they should be, I can add the link directly in Hover Editor. I never need to actually open any files. And I can add or remove words to my filter to find information that is related but perhaps worded differently. Finally, I can bookmark the graph and easily return to it later to discover new, related information using the same filters.\nAssuming I have already created notes on a topic, I will already have a map of content named after the topic. If the file doesn’t yet exist, I can click on the node to create it and manually add the standard template. This Map of Content will already have a list of related files and a graph view which shows them, both accessible in the right sidebar. Now, as I look at potentially relevant notes in Graph View and add links to the topic:: field, my MOC is accumulating the links, and a neural network is developing.\nThe right sidebar version of the graph provides an additional feature, the ability to adjust “levels”. This allows you to not only see notes linked to the current note, but also notes that are linked to those notes. In a family tree this is kind of like cousins, cousins once-removed, and so forth. Some of these more distant relations should/could be directly linked to the main topic.\nAnd remember, thanks to Hover Editor, I never have to open a file except when I create one.",
    "crumbs": [
      "Obsidian",
      "Obsidian: Meaningless Names, No Directories, Now What?"
    ]
  },
  {
    "objectID": "blogs/obsidian/freeing-your-thinking-part-2/index.html#knowledge-trees",
    "href": "blogs/obsidian/freeing-your-thinking-part-2/index.html#knowledge-trees",
    "title": "Obsidian: Meaningless Names, No Directories, Now What?",
    "section": "",
    "text": "Honestly, sometimes my brain just wants a list of things without extra visual stimulation. With Bookmarks, I can build knowledge trees for a topic, basically like a rich outline.\nI create a virtual (bookmark) directory for the topic. As I work with my information, I bookmark interesting blocks with information (I do not bookmark files, just information). These could be sections, paragraphs, images, embedded PDFs…anything really. Bookmarks can be named as well. For complex topics, I can create subdirectories as appropriate.\nThis results in what is essentially a detailed outline of all my information on a topic. A virtual Map of Content, if you will.",
    "crumbs": [
      "Obsidian",
      "Obsidian: Meaningless Names, No Directories, Now What?"
    ]
  },
  {
    "objectID": "blogs/obsidian/freeing-your-thinking-part-2/index.html#the-elephant-in-the-room",
    "href": "blogs/obsidian/freeing-your-thinking-part-2/index.html#the-elephant-in-the-room",
    "title": "Obsidian: Meaningless Names, No Directories, Now What?",
    "section": "The Elephant in the Room",
    "text": "The Elephant in the Room\nMore advanced users often use the Excalibrain plugin to visualize their vault. It is useful if you are thinking in terms of files and ontological relationships between them. I love the Excalidraw plugin and use it a lot for visual mocs. I had really hoped that I would like Excalibrain, too. But, for my process, it is inferior in a number of ways to Graph View.\nGraph View allows me to easily discover and interact with notes that are not yet linked to my topic. I can see orphans and adjust my filter, asking my questions in different ways, adding and removing search terms to reveal more potential relevant information.\nVisually, Excalibrain is blocky and static. Graph view is multi-form and dynamic. From a visual perspective, this is obviously personal preference. But the dynamism of Graph View is very useful and for me makes it superior.\nAs new notes are linked, all the nodes adjust to fit them in place, kind of like in your brain, in which new information shifts your thought patterns. Dragging nodes and changing force levels can emphasize relationships, and I can achieve elegant visual representations of my information this way. Notes can be visually grouped using colors, which is useful for complex topics with multiple sub-topics. The relative size of nodes indicates the information density of a note, suggesting other topics or sub-topics which could be developed. I find all of this useful.\nIn short, Graph View is fluid and flexible. Just the way I like my thinking.",
    "crumbs": [
      "Obsidian",
      "Obsidian: Meaningless Names, No Directories, Now What?"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-jupyter/index.html",
    "href": "blogs/obsidian/obsidian-jupyter/index.html",
    "title": "Obsidian and Jupyter Notebooks",
    "section": "",
    "text": "Personal Knowledge Management for Data Science\n\n\n\nJupyter notebooks, or more properly iPython notebooks, are fantastic tools for data exploration and modeling. You can run bits of code, interspersed with blocks of markdown, allowing you to easily work with data and present analyses and forecasts in a visual and interactive format. Notebooks can be easily shared via GitHub, or run on-line with Colab.\nThe problem with iPython notebooks, from a Personal Knowledge Management perspective, is they end up being “books on the shelf”. For Obsidian users and PKM practitioners, the whole point is to get away from keeping information in notebooks, with all the uselessness that that implies. One could, as you will see, just do data exploration directly in Obsidian instead of in a standard iPython notebook. But Obsidian is not an IDE. The ecosystem around the interactive Python notebook IDEs, be it Jupyter Lab itself, or VS Code, etc, is so useful, that working in Obsidian while exploring data and creating models would be unacceptably tedious. Using fit-for-purpose tools is very important for efficiency.\nWe need a painless way to capture all this information in our vault, making notes out of the notebooks. How can we easily make this information future-useful, without repeating/duplicating our efforts or doing a ton of copy/paste? In this article, I’ll explain the solution that works well for me, ensuring Obsidian-speed access to any bits of information I have in my notebooks, as well as making review and study activities so much more pleasant. And, of course, my canvases have all gotten richer as well.\n\n\n\nThe community plugin needed to accomplish this is called Execute Code, written by Tim Wibiral together with Jupyter and a library called nbconvert. The latter will convert the notebooks to markdown, and the plugin allows you to execute the code directly within a note. To get started, create a virtual environment for Obsidian to use. If you aren’t using virtual environments, please start now! It’s simple, and you will avoid future problems. From the command line, do:\nmkdir -p $HOME/.config/venvs && cd \"$_\"\npython -m venv obsidian_venv\nsource obsidian_venv/bin/activate\npip install --upgrade pip\npip install jupyterlab nbconvert \nYou can install other libraries like Pandas and Matplotlib as well into the virtual environment with pip install. Jupyter lab and nbconvert will be necessary to convert the notebooks to markdown. At this point, you could launch jupyter lab, but there is no need to. After installing packages, you can exit the virtual environment with deactivate. Should you need to install more packages later, you can type source $HOME/.config/venvs/obsidian_venv/bin/activate to re-enter the virtual environment and pip install other packages.\nIn Obsidian, install the Execute Code plugin. After installing the plugin you must point it to the version of Python you want to use, in this case the one we made in the virtual environment above. In the settings for the plugin, under the language-specific settings, choose Python from the drop down list. For Python Path, enter /home/directory/.config/venvs/obsidian_venv/bin/python.\nWith that done, any code block with the keyword python added directly after the opening back ticks of the block can be run in the Note. In Read view, a Run button will appear by each code block, allowing you to execute the code in the block. After execution, there will be a Clear button to clear up output that you want removed from the note. Code can also be executed from Edit view by using the keyword run-python rather than simply python. The plugin offers a command to run all the code in the note, as well as a command to view and kill any active runtimes.\n\n\n\nJupyter Lab can export an ipynb file directly to markdown! As of writing, VS Code can only export to py, pdf or html. From the file menu, select Export and choose Markdown. This will generate a zipped archive containing a markdown page, along with any image files in the notebook. The problem with this approach is that you will find all of the image files named output something, and so after exporting a few notebooks, there will be name conflicts in your vault.\nUsing the command line avoids this problem, and is in any case much more efficient. You will need to activate your virtual environment with source as described above. Then type\njupyter nbconvert --to Markdown your_notebook.ipynb\nThis will generate an md file which can be copied into your vault. If there are images from generated by the output, like graphs and other visuals, these will be put in a directory created by the above command. If you copy this directory, with all the image files into the vault directory that you use for attachments, the new md file will find them. (It is important to copy the directory itself and not just the files, since the new note will expect to find them there.)\nOnce in Obsidian you can process your Notebooks as any other file, breaking them into bite-size chunks of information. I rely heavily on “Extract this heading”, available with a right-click on any heading in a note. This replaces the section with a link to a newly-created note containing the section’s content. I find it useful to use a template that loads common libraries, since they will need to be added them at the top of the new files.\nWhen converting your notebooks to notes, be aware that different notes do not share the same runtime. Be sure to include all the variables/calculations necessary for the part of the code you extracted in the new file, as this will not be available from another file’s state. Also, any images that you link to in the markdown sections of the original notebook will need to be manually copied into the vault, as only images generated from code in the file will be exported. ## Closing Thoughts\nI first started using Obsidian for the specific purpose of studying data science. My use of Obsidian broadened considerably and quickly once I first began with it. However, after some time I realized that, because of the nature of iPython notebooks, and the necessity, or really the pleasure, of using them, I found myself many months later in the very position I was trying to avoid vis-a-vis my notes: information I needed was somewhere in my piles of notebooks, and I turned to Google more often than searching through my notebooks.\nNow I can immerse myself in the Python project or study I am focusing on, knowing that after I’m finished, generating proper atomic notes from the work I’m doing will be a breeze. I hope that you may find this information useful. Happy coding!",
    "crumbs": [
      "Obsidian",
      "Obsidian and Jupyter Notebooks"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-jupyter/index.html#motivation",
    "href": "blogs/obsidian/obsidian-jupyter/index.html#motivation",
    "title": "Obsidian and Jupyter Notebooks",
    "section": "",
    "text": "Jupyter notebooks, or more properly iPython notebooks, are fantastic tools for data exploration and modeling. You can run bits of code, interspersed with blocks of markdown, allowing you to easily work with data and present analyses and forecasts in a visual and interactive format. Notebooks can be easily shared via GitHub, or run on-line with Colab.\nThe problem with iPython notebooks, from a Personal Knowledge Management perspective, is they end up being “books on the shelf”. For Obsidian users and PKM practitioners, the whole point is to get away from keeping information in notebooks, with all the uselessness that that implies. One could, as you will see, just do data exploration directly in Obsidian instead of in a standard iPython notebook. But Obsidian is not an IDE. The ecosystem around the interactive Python notebook IDEs, be it Jupyter Lab itself, or VS Code, etc, is so useful, that working in Obsidian while exploring data and creating models would be unacceptably tedious. Using fit-for-purpose tools is very important for efficiency.\nWe need a painless way to capture all this information in our vault, making notes out of the notebooks. How can we easily make this information future-useful, without repeating/duplicating our efforts or doing a ton of copy/paste? In this article, I’ll explain the solution that works well for me, ensuring Obsidian-speed access to any bits of information I have in my notebooks, as well as making review and study activities so much more pleasant. And, of course, my canvases have all gotten richer as well.",
    "crumbs": [
      "Obsidian",
      "Obsidian and Jupyter Notebooks"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-jupyter/index.html#setting-up-obsidian",
    "href": "blogs/obsidian/obsidian-jupyter/index.html#setting-up-obsidian",
    "title": "Obsidian and Jupyter Notebooks",
    "section": "",
    "text": "The community plugin needed to accomplish this is called Execute Code, written by Tim Wibiral together with Jupyter and a library called nbconvert. The latter will convert the notebooks to markdown, and the plugin allows you to execute the code directly within a note. To get started, create a virtual environment for Obsidian to use. If you aren’t using virtual environments, please start now! It’s simple, and you will avoid future problems. From the command line, do:\nmkdir -p $HOME/.config/venvs && cd \"$_\"\npython -m venv obsidian_venv\nsource obsidian_venv/bin/activate\npip install --upgrade pip\npip install jupyterlab nbconvert \nYou can install other libraries like Pandas and Matplotlib as well into the virtual environment with pip install. Jupyter lab and nbconvert will be necessary to convert the notebooks to markdown. At this point, you could launch jupyter lab, but there is no need to. After installing packages, you can exit the virtual environment with deactivate. Should you need to install more packages later, you can type source $HOME/.config/venvs/obsidian_venv/bin/activate to re-enter the virtual environment and pip install other packages.\nIn Obsidian, install the Execute Code plugin. After installing the plugin you must point it to the version of Python you want to use, in this case the one we made in the virtual environment above. In the settings for the plugin, under the language-specific settings, choose Python from the drop down list. For Python Path, enter /home/directory/.config/venvs/obsidian_venv/bin/python.\nWith that done, any code block with the keyword python added directly after the opening back ticks of the block can be run in the Note. In Read view, a Run button will appear by each code block, allowing you to execute the code in the block. After execution, there will be a Clear button to clear up output that you want removed from the note. Code can also be executed from Edit view by using the keyword run-python rather than simply python. The plugin offers a command to run all the code in the note, as well as a command to view and kill any active runtimes.",
    "crumbs": [
      "Obsidian",
      "Obsidian and Jupyter Notebooks"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-jupyter/index.html#processing-a-notebook",
    "href": "blogs/obsidian/obsidian-jupyter/index.html#processing-a-notebook",
    "title": "Obsidian and Jupyter Notebooks",
    "section": "",
    "text": "Jupyter Lab can export an ipynb file directly to markdown! As of writing, VS Code can only export to py, pdf or html. From the file menu, select Export and choose Markdown. This will generate a zipped archive containing a markdown page, along with any image files in the notebook. The problem with this approach is that you will find all of the image files named output something, and so after exporting a few notebooks, there will be name conflicts in your vault.\nUsing the command line avoids this problem, and is in any case much more efficient. You will need to activate your virtual environment with source as described above. Then type\njupyter nbconvert --to Markdown your_notebook.ipynb\nThis will generate an md file which can be copied into your vault. If there are images from generated by the output, like graphs and other visuals, these will be put in a directory created by the above command. If you copy this directory, with all the image files into the vault directory that you use for attachments, the new md file will find them. (It is important to copy the directory itself and not just the files, since the new note will expect to find them there.)\nOnce in Obsidian you can process your Notebooks as any other file, breaking them into bite-size chunks of information. I rely heavily on “Extract this heading”, available with a right-click on any heading in a note. This replaces the section with a link to a newly-created note containing the section’s content. I find it useful to use a template that loads common libraries, since they will need to be added them at the top of the new files.\nWhen converting your notebooks to notes, be aware that different notes do not share the same runtime. Be sure to include all the variables/calculations necessary for the part of the code you extracted in the new file, as this will not be available from another file’s state. Also, any images that you link to in the markdown sections of the original notebook will need to be manually copied into the vault, as only images generated from code in the file will be exported. ## Closing Thoughts\nI first started using Obsidian for the specific purpose of studying data science. My use of Obsidian broadened considerably and quickly once I first began with it. However, after some time I realized that, because of the nature of iPython notebooks, and the necessity, or really the pleasure, of using them, I found myself many months later in the very position I was trying to avoid vis-a-vis my notes: information I needed was somewhere in my piles of notebooks, and I turned to Google more often than searching through my notebooks.\nNow I can immerse myself in the Python project or study I am focusing on, knowing that after I’m finished, generating proper atomic notes from the work I’m doing will be a breeze. I hope that you may find this information useful. Happy coding!",
    "crumbs": [
      "Obsidian",
      "Obsidian and Jupyter Notebooks"
    ]
  },
  {
    "objectID": "blogs/obsidian/freeing-your-thinking-workflow/index.html",
    "href": "blogs/obsidian/freeing-your-thinking-workflow/index.html",
    "title": "Obsidian: Freeing Your Thinking Workflow",
    "section": "",
    "text": "I recently published several articles on using Obsidian’s native database functionality to increase focus and efficiency when working with the information in our vaults. Rather than using Obsidian as a souped-up word processor, we can abandon the file paradigm altogether and use Bookmark and Canvas for accessing, editing, analyzing and organizing our information.\nGiven the interest that the articles have generated, and the fact that the concepts may be unfamiliar to some, I thought it would be helpful to make a video demonstrating how it works in practice. It ended up being somewhat long, so this is the second part.\nIf you haven’t read the articles, this may be confusing as I don’t go into depth on the concepts. This isn’t really a how-to video, so it assumes you know your way around Obsidian.\n\n\nPart 1\n\n\n\n\n\n\nPart 2\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Obsidian",
      "Obsidian: Freeing Your Thinking Workflow"
    ]
  },
  {
    "objectID": "blogs/obsidian/git-github-obsidian/index.html",
    "href": "blogs/obsidian/git-github-obsidian/index.html",
    "title": "Git and GitHub for Obsidian Users",
    "section": "",
    "text": "I’ve been doing some repair work around my house recently and have been reflecting on how important the choice of tools are in making a project go quickly and smoothly. More specifically, I’ve been thinking about how important it is to choose a tool designed for a specific purpose rather than a general purpose one. For example, while you can screw a nut on a bolt with vise grips, you’re much better off using ratchet wrench which is designed for that specific purpose. It is faster, easier, and less likely to do damage to the nut.\nI’ve been seeing quite a few articles about git and GitHub in the context of backups and synchronization. In this article I would like to explain exactly what they are and why they are not good tools to use for backing up or synchronizing an Obsidian vault. I will then propose best-of-class solutions for these needs. At the end, I will show how git and GitHub can, in fact, be useful for some special purposes. ## Git\nGit is a version control system designed for collaborative software development. Using git, developers are able to manage a project’s code base throughout development cycles, allowing multiple authors to contribute code to a single project, everyone keeping up to date with the latest version. It allows for maintaining separate branches for production and development, branches for features, and branches for each developer. The various branches can be merged as they are completed, and thereby update the production or main development branch.\nIf you are wondering how any of this relates to Obsidian, which is not a software development project and does not typically have multiple contributors, well, it doesn’t, which is kind of my point. It’s a vice grips solution for Obsidian.\nIts design is clever, though, and worth taking a moment to understand. The information generated by git is stored in a repository. A repository is simply a hidden directory created in the main directory of your project, or in this case, your vault. The repository itself keeps track of commits. A commit is a file which describes exactly what files have been added, removed, or edited since the last commit. In the case of edits, it keeps track of the specific changes made to each file by tracking changes to each line. The changes are combined with information such as the author of the change and a description of what was changed, and this becomes a new commit. The granularity allows for identifying specific lines which introduced bugs. They can then “re-set” the project to the prior, bug-free state while someone fixes the bug, or to a point where a deleted file still existed.\nBefore moving on, I will just point out that the git repository has nothing to do with GitHub. It’s just a hidden directory on your local file system.\n\n\nAt it’s core, GitHub is service like Dropbox which provides cloud storage. But there are important differences. It was specifically created to promote sharing of code and collaboration among software developers. As such, you can have as many free public repositories as you want, but need to pay for private ones. A limitation of GitHub is file size. There is a maximum size of 100 MB per file. This is not a problem for most people, but should you have any videos in your vault, for example, you will not be able to use GitHub at all. In any case, unless you need tools provided by GitHub, you might just as well copy your directory, or your local git repository, to Dropbox instead of pushing to GitHub.\nIn addition to storage, GitHub provides a whole suite of tools which developers can use to design automated workflows and even deploy projects directly from GitHub. None of this really applies to Obsidian either, with potential exceptions which I’ll describe below.\n\n\n\nAs we have seen, GitHub is designed for keeping multiple developers and project branches in sync, so it might seem to appropriate for keeping Obsidian vaults in sync. But, since there is only one author and only one branch, it is overkill at the very least. A developer pulls to see what others have done and pushes to share their work…neither relevant for Obsidian.\nBut my main objection is practical. Using GitHub requires manual interactions be performed every time you switch devices, namely a pull and a push to GitHub. Ideally, synchronization across devices should be automatic, instantaneous and real time. I wrote an article on synchronizing your vault across different devices using a tool called Syncthing. It is a free, fit for purpose tool which uses direct, device-to-device synchronization, requiring no intervention, and changes are immediately reflected across all devices. ## Backups Be honest: do you back up your computer regularly? If you are like the majority of people the answer is no. Given the number of articles I’ve seen on solutions for backing up vaults I can only conclude that many Obsidian users, like others, don’t have a regular backup system, because, if you are backing up your computer, you are backing up your vault. Obsidian is just another directory, and doesn’t need anything special. If you already perform regular backups, and have tested file recovery, then you don’t need to read the next bit…unless you are using GitHub for your backups.\nTo understand why GitHub should not be used to back up your vault, consider the main features required for a good backup system:\n\nEase of recovery - even people who actually do backups often do not test how quickly and easily it is to restore files from the backups. Ideally, you should be able to navigate through backed up files and directories just like ordinary ones, and then simply copy what you want. Recovering lost or old versions of files is possible using git, but the process is much more cumbersome.\nRotation of daily, weekly, monthly backups - a good backup system will automatically rotate your backups, removing unnecessary versions as they age and new ones are made. That way you can find something from two days, two weeks, two months or two years ago. Git provide no such functionality.\nSpeed and Space efficiency - over time, the amount of data you need to back up can be many gigabytes, especially if you have videos or many images. When you do a backup, the tool must check for changes across the entire directory, so it needs to be fast. At any point, you will have dozens of backups each representing a snapshot in time. In order to maintain so many “copies”, the system must be efficient in compressing the information. With git and GitHub there is no compression except for during file transfer.\nOff-site backups - Best practice for backups means storing at least one copy of your backups in a different physical location. This could be a cloud server. A good tool should make off-site backups just as easy as on-site backups. GitHub does fulfill this requirement.\n\nThe best backup system around is called Restic. It is free, open source, cross-platform, and can be easily managed with a few simple commands. Most importantly, it is blazing fast, and creates surprisingly small repositories. This is basically because it breaks up your files into variable-length blobs, or chunks of bytes. I will explain the details in a subsequent article. ## Sharing - use cases for git and GitHub\nI have found some very good use cases for git and GitHub. They involve sharing content of my vault. Before describing them, let me point out that sharing of vault content should generally only be one way. Obsidian is not meant to be a collaborative tool. So you, and only you, control what goes into your vault.\n\n\nGit, and especially GitHub itself, are convenient for creating live, interactive presentations from content in my vault. I can create a formal presentation using the Advanced Slides plugin, or just make a section of my vault with specific content and put that part on GitHub. GitHub allows others to browse the vault or view the presentation on-line. Alternatively, they can download the content, open it locally with Obsidian, or simply copy it into their own vault.\nIn the context of a presentation, git itself is useful, because a presentation is a product. Like any product, version control is useful. A presentation can change and evolve. Sometimes one wants to see something from a prior iteration of a project, and git makes this simple. In other words, presentations have versions.\nI’ll give some tips on the mechanics of how to do this at the end, but it’s simply a matter of collecting all the necessary files, including attachments, in a sub-directory of my vault. I copy this directory to a different location, open it as a vault and enable necessary plugins. GitHub can directly serve HTML files, so I convert the entire new vault to HTML with the Webpage HTML Export plugin. I create a README.md with some sort of linked table of contents or at least a link to enter the html files. With that done, I can just push to GitHub, and everything goes live in minutes on a url GitHub creates for me.\nAt this point I can make the presentation and the the audience can follow along on their own computers and engage with the content, either on-line or locally by downloading the vault from GitHub. If they happen to be Obsidian users, they could also copy the files into their own vault to further interact with the material.\n\n\n\nAs a teacher, it didn’t take long to consider how Obsidian might be used in the classroom. The idea of making and distributing course content which is easily navigable, visually interesting, and incorporates multi-media, graphs and charts, and external resources is very attractive. Sharing of content can be done the same way as the presentation above, and students could get it either “live” or by making their own copy.\nBut, as I do go on about, Obsidian is a database too, so why not push this a step further, and run the whole course with Obsidian, including design, distribution of materials, receiving assignments from students, applying rubrics if appropriate, grading and evaluations. This sounds like a project, and git and GitHub are perfect for this use. In addition to facilitating the distribution of the course materials, you can update the materials from time to time, and students will always have access to the latest version. I segregate the course into a public/ and private/ directory, and only push public/ to GitHub. All completed work, grades, evaluations, and any identifying material is kept confidential. Students can submit their responses by emailing the single note, which I simply place in the private/ directory. The Properties take care of everything else (except the actual grading).\nThis is obviously a more complex example, involving metadata (properties), Dataview, and various templates to provide the metadata and compile grades. A full description would take too long for this article, but I intend to write a detailed article with a sample vault in the near future.\n\n\n\n\nThis article is already long, so I can’t go into details about using git and GitHub, but I want to show how simple it is for this purpose. You need to install git itself, and I use another program called gh (the GitHub Client), which allows me to manage everything from the command line. With these installed and a free GitHub account, all I need to do is create the repository locally with the command git init. I then create the repository on GitHub itself with\ngh repo create my-vault-name --public --source=. --remote=upstream`. After that, whenever I add, delete or change content, I just do\ngit add .\ngit commit -m \"Some message\"\ngit push\nOn the GitHub website, under the Settings menu there is a Pages option. Simply go there and you can deploy your vault (with HTML rendered) with a couple of clicks. It will provide you with a live URL, where the content will be kept up to date every time you push.\nThat’s all there is to it.",
    "crumbs": [
      "Obsidian",
      "Git and GitHub for Obsidian Users"
    ]
  },
  {
    "objectID": "blogs/obsidian/git-github-obsidian/index.html#github",
    "href": "blogs/obsidian/git-github-obsidian/index.html#github",
    "title": "Git and GitHub for Obsidian Users",
    "section": "",
    "text": "At it’s core, GitHub is service like Dropbox which provides cloud storage. But there are important differences. It was specifically created to promote sharing of code and collaboration among software developers. As such, you can have as many free public repositories as you want, but need to pay for private ones. A limitation of GitHub is file size. There is a maximum size of 100 MB per file. This is not a problem for most people, but should you have any videos in your vault, for example, you will not be able to use GitHub at all. In any case, unless you need tools provided by GitHub, you might just as well copy your directory, or your local git repository, to Dropbox instead of pushing to GitHub.\nIn addition to storage, GitHub provides a whole suite of tools which developers can use to design automated workflows and even deploy projects directly from GitHub. None of this really applies to Obsidian either, with potential exceptions which I’ll describe below.",
    "crumbs": [
      "Obsidian",
      "Git and GitHub for Obsidian Users"
    ]
  },
  {
    "objectID": "blogs/obsidian/git-github-obsidian/index.html#synchronization",
    "href": "blogs/obsidian/git-github-obsidian/index.html#synchronization",
    "title": "Git and GitHub for Obsidian Users",
    "section": "",
    "text": "As we have seen, GitHub is designed for keeping multiple developers and project branches in sync, so it might seem to appropriate for keeping Obsidian vaults in sync. But, since there is only one author and only one branch, it is overkill at the very least. A developer pulls to see what others have done and pushes to share their work…neither relevant for Obsidian.\nBut my main objection is practical. Using GitHub requires manual interactions be performed every time you switch devices, namely a pull and a push to GitHub. Ideally, synchronization across devices should be automatic, instantaneous and real time. I wrote an article on synchronizing your vault across different devices using a tool called Syncthing. It is a free, fit for purpose tool which uses direct, device-to-device synchronization, requiring no intervention, and changes are immediately reflected across all devices. ## Backups Be honest: do you back up your computer regularly? If you are like the majority of people the answer is no. Given the number of articles I’ve seen on solutions for backing up vaults I can only conclude that many Obsidian users, like others, don’t have a regular backup system, because, if you are backing up your computer, you are backing up your vault. Obsidian is just another directory, and doesn’t need anything special. If you already perform regular backups, and have tested file recovery, then you don’t need to read the next bit…unless you are using GitHub for your backups.\nTo understand why GitHub should not be used to back up your vault, consider the main features required for a good backup system:\n\nEase of recovery - even people who actually do backups often do not test how quickly and easily it is to restore files from the backups. Ideally, you should be able to navigate through backed up files and directories just like ordinary ones, and then simply copy what you want. Recovering lost or old versions of files is possible using git, but the process is much more cumbersome.\nRotation of daily, weekly, monthly backups - a good backup system will automatically rotate your backups, removing unnecessary versions as they age and new ones are made. That way you can find something from two days, two weeks, two months or two years ago. Git provide no such functionality.\nSpeed and Space efficiency - over time, the amount of data you need to back up can be many gigabytes, especially if you have videos or many images. When you do a backup, the tool must check for changes across the entire directory, so it needs to be fast. At any point, you will have dozens of backups each representing a snapshot in time. In order to maintain so many “copies”, the system must be efficient in compressing the information. With git and GitHub there is no compression except for during file transfer.\nOff-site backups - Best practice for backups means storing at least one copy of your backups in a different physical location. This could be a cloud server. A good tool should make off-site backups just as easy as on-site backups. GitHub does fulfill this requirement.\n\nThe best backup system around is called Restic. It is free, open source, cross-platform, and can be easily managed with a few simple commands. Most importantly, it is blazing fast, and creates surprisingly small repositories. This is basically because it breaks up your files into variable-length blobs, or chunks of bytes. I will explain the details in a subsequent article. ## Sharing - use cases for git and GitHub\nI have found some very good use cases for git and GitHub. They involve sharing content of my vault. Before describing them, let me point out that sharing of vault content should generally only be one way. Obsidian is not meant to be a collaborative tool. So you, and only you, control what goes into your vault.\n\n\nGit, and especially GitHub itself, are convenient for creating live, interactive presentations from content in my vault. I can create a formal presentation using the Advanced Slides plugin, or just make a section of my vault with specific content and put that part on GitHub. GitHub allows others to browse the vault or view the presentation on-line. Alternatively, they can download the content, open it locally with Obsidian, or simply copy it into their own vault.\nIn the context of a presentation, git itself is useful, because a presentation is a product. Like any product, version control is useful. A presentation can change and evolve. Sometimes one wants to see something from a prior iteration of a project, and git makes this simple. In other words, presentations have versions.\nI’ll give some tips on the mechanics of how to do this at the end, but it’s simply a matter of collecting all the necessary files, including attachments, in a sub-directory of my vault. I copy this directory to a different location, open it as a vault and enable necessary plugins. GitHub can directly serve HTML files, so I convert the entire new vault to HTML with the Webpage HTML Export plugin. I create a README.md with some sort of linked table of contents or at least a link to enter the html files. With that done, I can just push to GitHub, and everything goes live in minutes on a url GitHub creates for me.\nAt this point I can make the presentation and the the audience can follow along on their own computers and engage with the content, either on-line or locally by downloading the vault from GitHub. If they happen to be Obsidian users, they could also copy the files into their own vault to further interact with the material.\n\n\n\nAs a teacher, it didn’t take long to consider how Obsidian might be used in the classroom. The idea of making and distributing course content which is easily navigable, visually interesting, and incorporates multi-media, graphs and charts, and external resources is very attractive. Sharing of content can be done the same way as the presentation above, and students could get it either “live” or by making their own copy.\nBut, as I do go on about, Obsidian is a database too, so why not push this a step further, and run the whole course with Obsidian, including design, distribution of materials, receiving assignments from students, applying rubrics if appropriate, grading and evaluations. This sounds like a project, and git and GitHub are perfect for this use. In addition to facilitating the distribution of the course materials, you can update the materials from time to time, and students will always have access to the latest version. I segregate the course into a public/ and private/ directory, and only push public/ to GitHub. All completed work, grades, evaluations, and any identifying material is kept confidential. Students can submit their responses by emailing the single note, which I simply place in the private/ directory. The Properties take care of everything else (except the actual grading).\nThis is obviously a more complex example, involving metadata (properties), Dataview, and various templates to provide the metadata and compile grades. A full description would take too long for this article, but I intend to write a detailed article with a sample vault in the near future.",
    "crumbs": [
      "Obsidian",
      "Git and GitHub for Obsidian Users"
    ]
  },
  {
    "objectID": "blogs/obsidian/git-github-obsidian/index.html#usage-of-git-and-github",
    "href": "blogs/obsidian/git-github-obsidian/index.html#usage-of-git-and-github",
    "title": "Git and GitHub for Obsidian Users",
    "section": "",
    "text": "This article is already long, so I can’t go into details about using git and GitHub, but I want to show how simple it is for this purpose. You need to install git itself, and I use another program called gh (the GitHub Client), which allows me to manage everything from the command line. With these installed and a free GitHub account, all I need to do is create the repository locally with the command git init. I then create the repository on GitHub itself with\ngh repo create my-vault-name --public --source=. --remote=upstream`. After that, whenever I add, delete or change content, I just do\ngit add .\ngit commit -m \"Some message\"\ngit push\nOn the GitHub website, under the Settings menu there is a Pages option. Simply go there and you can deploy your vault (with HTML rendered) with a couple of clicks. It will provide you with a live URL, where the content will be kept up to date every time you push.\nThat’s all there is to it.",
    "crumbs": [
      "Obsidian",
      "Git and GitHub for Obsidian Users"
    ]
  },
  {
    "objectID": "blogs/obsidian/graph-view-deets/index.html",
    "href": "blogs/obsidian/graph-view-deets/index.html",
    "title": "Obsidian: The mechanics of Graph View",
    "section": "",
    "text": "Core functionality in Obsidian seems to be somewhat overlooked. I have written in other articles about using Search, Bookmarks, and Unique Notes for Freeing Your Thinking. In these videos, I demonstrate the functionality of another core component, Graph View.\nA graph is a specific data structure consisting of nodes and edges. Obsidian consists of notes which are linked together. This type of data can be stored in a non-relational database. With links and metadata, Obsidian is a non-relational database.\nFor these reasons, graph view is a powerful way to visualize your data. Graph view is a force directed graph drawing. Where Obsidian search is the best way to find information, graph view is the best way to visualize information and discovering relationships which have not been defined, such as orphans.\nThese videos go through the details of the graph view functionality in the hope that you will begin to use it to visualize data.",
    "crumbs": [
      "Obsidian",
      "Obsidian: The mechanics of Graph View"
    ]
  },
  {
    "objectID": "blogs/obsidian/graph-view-deets/index.html#part-1",
    "href": "blogs/obsidian/graph-view-deets/index.html#part-1",
    "title": "Obsidian: The mechanics of Graph View",
    "section": "Part 1",
    "text": "Part 1",
    "crumbs": [
      "Obsidian",
      "Obsidian: The mechanics of Graph View"
    ]
  },
  {
    "objectID": "blogs/obsidian/graph-view-deets/index.html#part-2",
    "href": "blogs/obsidian/graph-view-deets/index.html#part-2",
    "title": "Obsidian: The mechanics of Graph View",
    "section": "Part 2",
    "text": "Part 2",
    "crumbs": [
      "Obsidian",
      "Obsidian: The mechanics of Graph View"
    ]
  },
  {
    "objectID": "blogs/obsidian/metadata-menu/index.html",
    "href": "blogs/obsidian/metadata-menu/index.html",
    "title": "Obsidian Metadata Menu Plugin",
    "section": "",
    "text": "Metadata Menu\nWith the release of Obsidian 1.4.5, many people’s focus has been on metadata, which Obsidian calls Properties. I have written a series of articles (see Freeing Your Thinking) on using Obsidian’s natural database features, and my entire workflow depends heavily on metadata. Naturally, I was anticipating this release with some excitement, having seen some previews on YouTube.\nI was frankly disappointed. It is movement in a positive direction, and has some very nice features for managing metadata. However, its insistence on YAML for properties when many users such as myself prefer in-line metadata for its flexibility, makes some of its features useless to me.\nAnother reason for my disappointment, or feeling underwhelmed, was that I had already discovered a truly amazing plugin for managing metadata which did everything I need and more. Metadata Menu, a Community Plugin by mathieu, provides a full set of features for managing properties. It has a modal, available in multiple places, which allows you to manage literally all aspects of a file’s metadata without opening the file, perfect for my workflow. It even has a file class template system which supports nesting groups of metadata fields. Fields in tables can have actions, allowing for direct editing of metadata in the table itself using standard widgets. And, it is visually clean and attractive\nThis video isn’t a guide to using Metadata Menu. Rather, it’s to show off some of its features. If metadata is important to you, you must check it out.\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Obsidian",
      "Obsidian Metadata Menu Plugin"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-headers/index.html",
    "href": "blogs/obsidian/obsidian-headers/index.html",
    "title": "Obsidian Basics - Headers",
    "section": "",
    "text": "Besides the actual content of a note, the most important elements in notes are the headers. More than just enhancing visual presentation of your information, headers give access to a variety of useful functionality. In this article, I will discuss the value of headers as well as the mechanics of using them.",
    "crumbs": [
      "Obsidian",
      "Obsidian Basics - Headers"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-headers/index.html#structure",
    "href": "blogs/obsidian/obsidian-headers/index.html#structure",
    "title": "Obsidian Basics - Headers",
    "section": "Structure",
    "text": "Structure\nHeaders allow you to divide your note in logical sections. You can use them like you would an outline, as described above. Every note should, at a minimum, a level one header at the beginning with a title for the note.\nObsidian helps me organize my thoughts. A note often “starts life” as a sentence or two that I “jotted down” when the thought came to me. When I return to the note, if I still find it interesting, the first thing I do is give it a title (level one header). It summarizes the purpose of the note succinctly, and for a simple, atomic note, that may be all I need, although I might want to include some reference information, in which case I create two level-two headers, one for content, one for references. And so on…\nHowever, for more complex notes which are not atomic, developing the note almost always involves breaking down the idea into parts. This is the purpose of headers. If you’re one of those people who like to start with an outline, start a new document with a bunch of headers. Even if you don’t, as you work on documents you will naturally need to break things down into smaller ideas…headers help you structure your thinking.",
    "crumbs": [
      "Obsidian",
      "Obsidian Basics - Headers"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-headers/index.html#navigation",
    "href": "blogs/obsidian/obsidian-headers/index.html#navigation",
    "title": "Obsidian Basics - Headers",
    "section": "Navigation",
    "text": "Navigation\nIf you open your right sidebar and click on the Outline icon, you will see the table of contents panel with an outline created by your headers. Clicking on any item will take you to that section of the document. Subsections can be folded in the panel by clicking on the down arrow to the left of the section. This is very useful for long documents.",
    "crumbs": [
      "Obsidian",
      "Obsidian Basics - Headers"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-headers/index.html#folding",
    "href": "blogs/obsidian/obsidian-headers/index.html#folding",
    "title": "Obsidian Basics - Headers",
    "section": "Folding",
    "text": "Folding\nIf you move your cursor over a header in your document, you will see a down arrow to the left of the header. This is a toggle which allows you to collapse (hide) or expand (show) a section’s content.\nA section includes all content up to the next Header of the same level or higher. So a level 3 section would include all content up until the next level 3 Header, or a level 2 or 1 Header. This can be confusing to explain, but if you experiment a little it should be clear.\nThere are commands that allow you to work more easily with folds. If you go into the command palette (Ctrl-P) you will see four commands which allow you to expand and collapse folds.\n\nThese commands are really only useful if you assign them hotkeys. If you do so you will find that navigating long documents becomes very quick, assuming that Headers are well-used.",
    "crumbs": [
      "Obsidian",
      "Obsidian Basics - Headers"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-headers/index.html#hooks-for-links",
    "href": "blogs/obsidian/obsidian-headers/index.html#hooks-for-links",
    "title": "Obsidian Basics - Headers",
    "section": "Hooks for Links",
    "text": "Hooks for Links\nThe final aspect of headers I’d like to mention is their use as reference hooks for links. When linking to another note, you can directly link to a header and therefore to a section. When creating a link, directly after the name of the note and inside the square brackets, you can type # and you will get a drop-down list of all the headers in the note. You can select one of these headers. Then the embedded document will only display that section in your current note. Similarly, hovering over the link and pressing Ctrl (if using the Hover Editor plugin) will display that section. More advanced plugins like dataview can also reference Headers.\nNB. You can also link directly to paragraphs by using #^ after the note’s name.",
    "crumbs": [
      "Obsidian",
      "Obsidian Basics - Headers"
    ]
  },
  {
    "objectID": "blogs/data-science/gpx-gps-data/index.html",
    "href": "blogs/data-science/gpx-gps-data/index.html",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I’m most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a “you are here”, if you will, or maybe “There, but for the grace of God…”.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my “friends” like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I’d happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I’m doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into “trajectories”, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Obsidian",
      "Data Science",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "blogs/data-science/gpx-gps-data/index.html#introduction",
    "href": "blogs/data-science/gpx-gps-data/index.html#introduction",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I’m most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a “you are here”, if you will, or maybe “There, but for the grace of God…”.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my “friends” like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I’d happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I’m doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into “trajectories”, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Obsidian",
      "Data Science",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "blogs/data-science/gpx-gps-data/index.html#next-steps",
    "href": "blogs/data-science/gpx-gps-data/index.html#next-steps",
    "title": "Trail Mapping with Python",
    "section": "Next steps",
    "text": "Next steps\nI naturally want to be able to make calculations of speed and distance, identify pauses, and do other exploration. Starting from discrete points, the steps to do so manually would be simple but exceedingly tedious. Fortunately there is a wonderful library called movingpandas which makes these things all very simple. I’ll explore that in the next articles.\nI’ll go ahead and save the GeoDataFrames for future use:\ntrek_gdf.to_file('data/trek_gdf.gpkg', driver='GPKG')\ntrek_projected.to_file('data/trek_projected.gpkg', driver='GPKG')",
    "crumbs": [
      "Obsidian",
      "Data Science",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-bookmarks/index.html",
    "href": "blogs/obsidian/obsidian-bookmarks/index.html",
    "title": "Obsidian Bookmarks",
    "section": "",
    "text": "Bookmarks are the key to effectively using obsidian as a non-relational database. The virtues of approaching your notes this way are several and I covered some in [[Freeing Your Thinking]]. In this article I want to develop the idea of using Bookmarks to construct flexible, interactive Knowledge Trees to organize notes. Just as a reminder, we are organizing information, not files.\nThe Navigation tab gives at best a static arrangement of information, while the Bookmarks tab provides a dynamic way to interact with, develop and access your information. Here you can create Views of your information which you can organize by domain, subject, activity, etc. Views are saved filters and queries. Your information, unlike your files, can happily exist in multiple places in your Knowledge Tree.\nWhen you begin to build your Knowledge Tree, you might start by creating Views which map to your current directories using filters. After all, you want to preserve the information you have put into your vault by organizing your notes in a File Tree. Most people have a separate directory for fleeting notes, so you might make a view containing path: \"fleeting-note-directory\". But is such a view terribly useful? Browsing through all your fleeting notes is fun if you’ve nothing better to do, but it’s not focused or efficient use of time if you are working on a particular topic. Wouldn’t it be better to just see the fleeting notes related to my topic? So I save the filter Whatever Topic \\type:: fleeting\\ alongside my views of the topic itself and have a list of fleeting notes only on that topic.\nAs you start mapping your old directories to views, you might begin to ask yourself at some point why you would ever really want to see all your MOCs in a list? Or Daily Notes? Or Logs? If you want information from these types of notes you typically create a note containing a Dataview query. Bookmarked filters, which I’m calling views, are like virtual Dataview queries. And, since you can do this without referencing file locations, you might question how much useful information was actually embedded in your folder structure. Then you might have a cup of tea.\nOne last point to stress: the bookmarks, which I will call views, are ephemeral. They can be created, duplicated, renamed and moved around without affecting the information itself. When focusing on a topic, drag it to the top of the tree and put it back when you are done.",
    "crumbs": [
      "Obsidian",
      "Obsidian Bookmarks"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-bookmarks/index.html#commands",
    "href": "blogs/obsidian/obsidian-bookmarks/index.html#commands",
    "title": "Obsidian Bookmarks",
    "section": "Commands",
    "text": "Commands\nThe following table shows the bookmarks commands with suggested Hotkeys which are most likely unassigned.\n\n\n\n\n\n\n\n\nCommand\nDescription\nHotkey\n\n\n\n\nBookmark…\nBookmark current file\nCtrl-Cmd-Alt-M\n\n\nShow Bookmarks\nOpen bookmarks panel\nCtrl-B\n\n\nBookmark Current Search\n\nCtrl-Cmd-Alt-S\n\n\nBookmark Current Block\nBookmark Block Under Cursor\nCtrl-Cmd-Alt-B\n\n\nBookmark Current Heading\nBookmark Heading Under Cursor\nCtrl-Cmd-Alt-H",
    "crumbs": [
      "Obsidian",
      "Obsidian Bookmarks"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-bookmarks/index.html#bookmarks-panel",
    "href": "blogs/obsidian/obsidian-bookmarks/index.html#bookmarks-panel",
    "title": "Obsidian Bookmarks",
    "section": "Bookmarks Panel",
    "text": "Bookmarks Panel\nThe panel lists all bookmarks, which, remember, are saved searches, or views. In the panel you can create, rename and delete bookmark groups to organize your bookmarks. Bookmarks can be dragged around to rearrange them.",
    "crumbs": [
      "Obsidian",
      "Obsidian Bookmarks"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-bookmarks/index.html#living",
    "href": "blogs/obsidian/obsidian-bookmarks/index.html#living",
    "title": "Obsidian Bookmarks",
    "section": "Living",
    "text": "Living\nThis is the structure of my Living section:\n- Daily Notes\n- Logs\n    - Exercise\n    - Piano\n    - etc.\n- Daily Notes\n- CV\n- People\n- Leisure\nDaily Notes is a view of type:: daily. Exercise and Piano are actual files with interactive Dataview queries. The rest are bookmark groups containing other views.",
    "crumbs": [
      "Obsidian",
      "Obsidian Bookmarks"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-bookmarks/index.html#learning",
    "href": "blogs/obsidian/obsidian-bookmarks/index.html#learning",
    "title": "Obsidian Bookmarks",
    "section": "Learning",
    "text": "Learning\nI use Learning for study and research activities. This part of the tree is the most complex in terms of structure.\nBy creating multiple views on a given topic and organizing them in folders I can essentially create an outline of my information using views. This kind of outline, again, is very flexible and can be reshaped easily as my knowledge develops.\nThis is an excerpt of my section on the normal distribution. It’s “home” is in the bookmark group Learing/Data Science/Probability/.\nNormal Distribution                 # All information on the Normal Distribution\nNormal Distribution                 # The reference note on the topic\n                                      The 2 are distinguished by different icons\nCentral Limit Theorem               # A bookmark group containing other views\n68-95-99.7 Rule                     # A view of a block in a note\nR Functions for Normal Distribution # A view of a section of a note",
    "crumbs": [
      "Obsidian",
      "Obsidian Bookmarks"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-bookmarks/index.html#creating",
    "href": "blogs/obsidian/obsidian-bookmarks/index.html#creating",
    "title": "Obsidian Bookmarks",
    "section": "Creating",
    "text": "Creating\nis for writing and creation of other content. Creating includes works for external and internal use.\n- Articles\n- Stories\n- Video Scripts\n- Musings",
    "crumbs": [
      "Obsidian",
      "Obsidian Bookmarks"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-bookmarks/index.html#toolbox",
    "href": "blogs/obsidian/obsidian-bookmarks/index.html#toolbox",
    "title": "Obsidian Bookmarks",
    "section": "Toolbox",
    "text": "Toolbox\nIn the toolbox I have the following directories, which should be self-explanatory:\n- Templates\n- fileClasses\n    - Class Definitions\n    - Value Lists\n- Fleeting Notes\n- Other\n    - Articles\n    - MOCs\n    - References\n    - Atomics\nOther than templates and fileClasses, I rarely use the Toolbox.",
    "crumbs": [
      "Obsidian",
      "Obsidian Bookmarks"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "This article is a follow-up to my Gentle Introduction to DataviewJS articles, and assumes that you have read them. It is written for anglers, but if you just want the fish you can Tldr; your way to the bottom an just grab the code. Even if you are here to learn how to fish, depending on your learning style, you may want to take a look at the complete code first before this walk-through.\nWe are now ready to start building a fully dynamic and interactive dashboard to manage the exercise logs. In this case, I’m tracking the following:\n\ntype of activity\ndistance\nduration\ndate of activity\nroute\n\nI have optional fields for notes and, as you can see, for images. Summary tables are generated using calculated values. The entire canvas updates automatically to the current day.\nThis example could easily be extended for tracking anything which includes numerical data and images. Imagine a research project, for example, where observations are taken combining numerical data, textual observations, and photos. Actually creating the log entries, thanks to Metadata Menu and Unique Notes, takes almost no time. You can read about how to do this here.\nIn this article, I’ll focus on creating this dynamic table.\n\nAppropriate widgets are provided allowing for direct editing or the use of popup modals for multi-select fields and dates. The list will display all logs over the last 7 days, so different logs will appear depending on the day.\nTo do this, we will use the excellent JavaScript functionality provided by Metadata Menu. It would be more interesting were you to create a bunch of logs (notes) covering a date range of at least three months and follow along. They should all contain the following fields:\n\ntopic\ntype\nRoute\nActivity\nDuration\nDistance\nNote\nImage\nLink\n\n\n\n\nThroughout this dashboard I work with time. It is natural to want to look at time periods of weeks and months, and to compare current periods to prior periods of the same length. We, just as naturally, compare a week starting Monday or Sunday to a prior week starting on the same day. And we compare February to January. This is often a good thing, because it fits the way people naturally think.\nBut if you are really looking at the numbers, you quickly see the flaw in comparing time periods this way. You can’t compare a complete week to the prior week until the end of the week. To get around this, people use week-to-date, or quite commonly month-to-date. For months the problem is worse, as in the case of Feb/Jan comparison that’s 28 days compared to 31 days. That’s more than a 10% difference in days, and therefor in data!\nA simple way around this, and one which provides better analysis, is to use rolling windows of time. Any seven day period contains every day of the week, and so comparing two of any such periods valid (and complete) week-to-week comparisons. For months, you can compare any 30 (or 28) day period to the prior period of equal length, so you get a full, month-long picture with apples-to-apples data (that’s a technical term😉).\nIn the first article I introduced moment(), an object provided by Dataview (by MomentJS actually). This makes time math easy. moment() itself means today, now, this very second. If you want the date/time two days ago, you can subtract two days with moment().subtract(2, \"days\"). I’ll leave it as an exercise to the reader to figure out how to find the date two months ago.\nIn order to use moment() for any date other than now, you need to write, eg., moment(new Date(\"2023-10-20\"). We will do this so that we can format the date differently using the format() function in moment(). format() wants an argument, a date format string. I don’t need to see the year, and a 2-digit month is fine and shorter. On the other hand, seeing the day of the week would be useful. The format string to produce “10/10 Tue” is “MM/DD ddd”. ### Challenge As an exercise, you might pause here and think about how to display “two days ago” in the format “10/10 Tue”. You have all the knowledge you need. Think about chaining commands together with the period. ### Solution\nHere is a solution:\nconst dateFormat = \"MM/DD ddd\" const twoDaysAgo =\nmoment() .subtract(2, \"days\") .format(dateFormat)\n\ndv.paragraph(twoDaysAgo)\nWhen writing, and especially reading, code, formatting is important. I could have written\nconst twoDaysAgo = moment().subtract(2, \"days\").format(dateFormat)\nbut it is much less clear what is going on. If you are trying to understand a piece of code, start by reformatting. ## Asynchronous Functions\nMost computer programs execute line by line, with each line completing before moving on to the next line. Normally this is what you want. However, as the quantity of data commonly worked with increases geometrically, and the fact that it is often distributed widely across the internet, applications which require fetching data can easily grind to a halt due to a slow internet connection, slow servers, large quantities, etc. To overcome this problems, some functions are executed asynchronously. When an asynchronous function is executed, it doesn’t return the actual data. Instead, it returns what is called a promise. That allows the program to continue executing while the data is being fetched. It will continue execution until the data is actually required, at which point it will wait (not freeze).\nIn practice this is quite easy, involving the use of two new key words: async and await. The first, async, is added to the function definition, and the second, await, is added before any data fetching. That’s all you need to know so that you will understand the words when you see them.\n\n\n\nMetadata Menu provides an asynchronous function for making the tables interactive. To use the function, you must import it with\nconst {fieldModifier: f} = this.app.plugins.plugins[\"metadata-menu\"].api\nUsing the curly braces like this is called deconstructing a variable or function. This means that somewhere there is a function called fieldModifier. The : f is just an alias, so that every time you use the function you don’t need to write out fieldModifier, you can just write f.\nThe other part is interesting. Take it step by step. this is the root directory of your vault. app is the hidden obsidian directory, inside of which there is, you guessed it, a plugins directory with an entry called metadata-menu. The rest, plugins[\"metadata-menu\"].api says to look in the metadata-menu directory for something called api. This object will contain a function called fieldModifier, which we can now refer to simply as f.\nfieldModifier(), which is f() to us now, is used in map() and takes three arguments: the dv object, whatever temporary variable you are using in map() (we have been using b), and the name of the field we want. Were it a normal function you would write\ndataviewjs dv.pages()     \n  .map(b=&gt;[p.ActivityDate, \n  f(dv, b, \"Activity\"),\n  ]\nSince this fetching of date is asynchronous, you have to use the key words async/await here, so\ndataviewjs dv.pages()     \n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ]\nThe entire section containing pages().map needs to be wrapped in an asynchronous function called Promise.all(), which must be (a)waited for and returns, unsurprisingly, a promise.\nawait Promise.all(dv.pages()\n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ])\n\n\n\nNow, lets finally take a look at the entire code that creates the dashboard. Take some time to read through it. Everything should be understandable at this point.\nconst {fieldModifier: f} =\nthis.app.plugins.plugins\\[\"metadata-menu\"\\].api\n\nconst dateFormat = \"MM/DD ddd\"\n\ndv.header(3, \"7 Day Details\")\n\ndv.table(\\[\"🗓️\",\"🚶🚴\", \"📓\", \"⏱️\", \"🗺️\"\\],\n\nawait Promise.all(dv.pages()\n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\n    .sort(p =&gt; p.ActivityDate, \"desc\")\n    .map(async b=&gt;[\n        moment(new Date(b.ActivityDate)).format(dateFormat),\n        await f(dv, b, \"Activity\"), \n        await f(dv, b, \"Distance\"), \n        await f(dv, b, \"Duration\"), \n        await f(dv, b, \"Route\"),\n    ]\n  )\n)\n\n\n\nIn the next article I will explain how to generate summary information like totals and averages for display on the dashboard. In the mean time I strongly suggest that you do two things:\n\nAdd images to some of your logs and create the table for the Gallery section of the dashboard\nTurn some of your existing Dataview tables into DataviewJS tables. Or, at least, make some new ones from your own information\nSpend some time working with date ranges. In this example, we selected the past seven days. How can you select the seven days prior to that? (Hint: you need to chain together two where() clauses.)\nCan you create a month-to-date view? There are various ways to do it, but it’s helpful to know that you can do moment().startOf('month') to grab the first day of the month. Check out the documentation for more possibilities.\n\nHappy coding!",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#introduction",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#introduction",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "This article is a follow-up to my Gentle Introduction to DataviewJS articles, and assumes that you have read them. It is written for anglers, but if you just want the fish you can Tldr; your way to the bottom an just grab the code. Even if you are here to learn how to fish, depending on your learning style, you may want to take a look at the complete code first before this walk-through.\nWe are now ready to start building a fully dynamic and interactive dashboard to manage the exercise logs. In this case, I’m tracking the following:\n\ntype of activity\ndistance\nduration\ndate of activity\nroute\n\nI have optional fields for notes and, as you can see, for images. Summary tables are generated using calculated values. The entire canvas updates automatically to the current day.\nThis example could easily be extended for tracking anything which includes numerical data and images. Imagine a research project, for example, where observations are taken combining numerical data, textual observations, and photos. Actually creating the log entries, thanks to Metadata Menu and Unique Notes, takes almost no time. You can read about how to do this here.\nIn this article, I’ll focus on creating this dynamic table.\n\nAppropriate widgets are provided allowing for direct editing or the use of popup modals for multi-select fields and dates. The list will display all logs over the last 7 days, so different logs will appear depending on the day.\nTo do this, we will use the excellent JavaScript functionality provided by Metadata Menu. It would be more interesting were you to create a bunch of logs (notes) covering a date range of at least three months and follow along. They should all contain the following fields:\n\ntopic\ntype\nRoute\nActivity\nDuration\nDistance\nNote\nImage\nLink",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#time-math",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#time-math",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "Throughout this dashboard I work with time. It is natural to want to look at time periods of weeks and months, and to compare current periods to prior periods of the same length. We, just as naturally, compare a week starting Monday or Sunday to a prior week starting on the same day. And we compare February to January. This is often a good thing, because it fits the way people naturally think.\nBut if you are really looking at the numbers, you quickly see the flaw in comparing time periods this way. You can’t compare a complete week to the prior week until the end of the week. To get around this, people use week-to-date, or quite commonly month-to-date. For months the problem is worse, as in the case of Feb/Jan comparison that’s 28 days compared to 31 days. That’s more than a 10% difference in days, and therefor in data!\nA simple way around this, and one which provides better analysis, is to use rolling windows of time. Any seven day period contains every day of the week, and so comparing two of any such periods valid (and complete) week-to-week comparisons. For months, you can compare any 30 (or 28) day period to the prior period of equal length, so you get a full, month-long picture with apples-to-apples data (that’s a technical term😉).\nIn the first article I introduced moment(), an object provided by Dataview (by MomentJS actually). This makes time math easy. moment() itself means today, now, this very second. If you want the date/time two days ago, you can subtract two days with moment().subtract(2, \"days\"). I’ll leave it as an exercise to the reader to figure out how to find the date two months ago.\nIn order to use moment() for any date other than now, you need to write, eg., moment(new Date(\"2023-10-20\"). We will do this so that we can format the date differently using the format() function in moment(). format() wants an argument, a date format string. I don’t need to see the year, and a 2-digit month is fine and shorter. On the other hand, seeing the day of the week would be useful. The format string to produce “10/10 Tue” is “MM/DD ddd”. ### Challenge As an exercise, you might pause here and think about how to display “two days ago” in the format “10/10 Tue”. You have all the knowledge you need. Think about chaining commands together with the period. ### Solution\nHere is a solution:\nconst dateFormat = \"MM/DD ddd\" const twoDaysAgo =\nmoment() .subtract(2, \"days\") .format(dateFormat)\n\ndv.paragraph(twoDaysAgo)\nWhen writing, and especially reading, code, formatting is important. I could have written\nconst twoDaysAgo = moment().subtract(2, \"days\").format(dateFormat)\nbut it is much less clear what is going on. If you are trying to understand a piece of code, start by reformatting. ## Asynchronous Functions\nMost computer programs execute line by line, with each line completing before moving on to the next line. Normally this is what you want. However, as the quantity of data commonly worked with increases geometrically, and the fact that it is often distributed widely across the internet, applications which require fetching data can easily grind to a halt due to a slow internet connection, slow servers, large quantities, etc. To overcome this problems, some functions are executed asynchronously. When an asynchronous function is executed, it doesn’t return the actual data. Instead, it returns what is called a promise. That allows the program to continue executing while the data is being fetched. It will continue execution until the data is actually required, at which point it will wait (not freeze).\nIn practice this is quite easy, involving the use of two new key words: async and await. The first, async, is added to the function definition, and the second, await, is added before any data fetching. That’s all you need to know so that you will understand the words when you see them.",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#metadata-menu",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#metadata-menu",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "Metadata Menu provides an asynchronous function for making the tables interactive. To use the function, you must import it with\nconst {fieldModifier: f} = this.app.plugins.plugins[\"metadata-menu\"].api\nUsing the curly braces like this is called deconstructing a variable or function. This means that somewhere there is a function called fieldModifier. The : f is just an alias, so that every time you use the function you don’t need to write out fieldModifier, you can just write f.\nThe other part is interesting. Take it step by step. this is the root directory of your vault. app is the hidden obsidian directory, inside of which there is, you guessed it, a plugins directory with an entry called metadata-menu. The rest, plugins[\"metadata-menu\"].api says to look in the metadata-menu directory for something called api. This object will contain a function called fieldModifier, which we can now refer to simply as f.\nfieldModifier(), which is f() to us now, is used in map() and takes three arguments: the dv object, whatever temporary variable you are using in map() (we have been using b), and the name of the field we want. Were it a normal function you would write\ndataviewjs dv.pages()     \n  .map(b=&gt;[p.ActivityDate, \n  f(dv, b, \"Activity\"),\n  ]\nSince this fetching of date is asynchronous, you have to use the key words async/await here, so\ndataviewjs dv.pages()     \n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ]\nThe entire section containing pages().map needs to be wrapped in an asynchronous function called Promise.all(), which must be (a)waited for and returns, unsurprisingly, a promise.\nawait Promise.all(dv.pages()\n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ])",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#the-table",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#the-table",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "Now, lets finally take a look at the entire code that creates the dashboard. Take some time to read through it. Everything should be understandable at this point.\nconst {fieldModifier: f} =\nthis.app.plugins.plugins\\[\"metadata-menu\"\\].api\n\nconst dateFormat = \"MM/DD ddd\"\n\ndv.header(3, \"7 Day Details\")\n\ndv.table(\\[\"🗓️\",\"🚶🚴\", \"📓\", \"⏱️\", \"🗺️\"\\],\n\nawait Promise.all(dv.pages()\n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\n    .sort(p =&gt; p.ActivityDate, \"desc\")\n    .map(async b=&gt;[\n        moment(new Date(b.ActivityDate)).format(dateFormat),\n        await f(dv, b, \"Activity\"), \n        await f(dv, b, \"Distance\"), \n        await f(dv, b, \"Duration\"), \n        await f(dv, b, \"Route\"),\n    ]\n  )\n)",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#next-steps",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#next-steps",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "In the next article I will explain how to generate summary information like totals and averages for display on the dashboard. In the mean time I strongly suggest that you do two things:\n\nAdd images to some of your logs and create the table for the Gallery section of the dashboard\nTurn some of your existing Dataview tables into DataviewJS tables. Or, at least, make some new ones from your own information\nSpend some time working with date ranges. In this example, we selected the past seven days. How can you select the seven days prior to that? (Hint: you need to chain together two where() clauses.)\nCan you create a month-to-date view? There are various ways to do it, but it’s helpful to know that you can do moment().startOf('month') to grab the first day of the month. Check out the documentation for more possibilities.\n\nHappy coding!",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/obsidian-no-sql-database/index.html",
    "href": "blogs/obsidian/obsidian-no-sql-database/index.html",
    "title": "What does it mean that is a NoSQL Database?",
    "section": "",
    "text": "SQL and NoSQL\nThere are two different types of databases, relational and non-relational. Relational databases are the kind most people usually think about. Data is kept in tables, with columns for fields and rows for values. The tables have special columns which relate (link) them to other tables. A well-formed table in a spreadsheet is a database. If two are linked by a common column, that is a relational database.\nObsidian is obviously not a relational database.\nSQL stands for Structured Query Language, and it is the syntax which was designed to work with relational databases. The association of the syntax and data structure is so strong that relational databases came to be referred to as SQL databases, even though SQL, the language, can be used with any type of database.\nAn SQL query should look familiar to you if you have used Dataview:\nSELECT name FROM users WHERE location = “Earth” ORDER BY age;\nIt’s just like Dataview queries, yet Obsidian is not an “SQL database”. My point is that we can use SQL queries to access our data even if it isn’t a relational database.\nThe other type of database, a non-relational database, is unfortunately called a NoSQL database. SQL, the language, can still be used to query data in a NoSQL database. If I’ve adequately confused you, let’s proceed.\nRather than storing data in tables, NoSQL databases store data in documents. Documents are text files written in a standard format, usually JSON (JavaScript Object Notation) but frequently YAML, which is the syntax used in frontmatter in Obsidian.\nIn a NoSQL database, documents contain information and metadata in key/value pairs. The metadata can be used to make relationships (links) between data (information). NoSQL databases are flexible and new key/value pairs can be added to a document without modifying a whole table. None of the relationships need be pre-defined, nor need they be hierarchical. NoSQL databases are ideal for data structures which consist of nodes (documents) and edges (links). Does any of this sound familiar?\nObsidian is a NoSQL database.\n\n\nOn Ontologies\nCommonly used organizational systems often focus on ontological relationships. Four relationships exist: parent, child, sibling, and friend. First, note that the first three are essentially the same since when a parent is defined, child and sibling relationships are logically specified. So we really only have two categories, which could just as easily be called “directly related” and “indirectly related”. Also, notice that in file-based hierarchical, ontological data structures a note (usually) has, rather unnaturally, only one parent.\nObsidian offers core functionality that allows me to ignore files and focus on information. I’m referring to Search, Bookmarks and Unique Notes. The latter is effectively invisible in articles and videos, and the other two rarely come up. This is especially surprising with regard to Search because that’s the most efficient and powerful way to find information in your vault. Most presenters use Quick Switcher or the Navigator to create and access files in order to create or access information. This is an extra step, wasting time and energy and impeding the flow of thought.\nSQL databases rely on hierarchy. NoSQL databases don’t. By thinking in hierarchical, ontological terms, we tie ourselves to a table-based way of thinking. By thinking instead about direct and indirect relationships, a note can have multiple “parents” because it can naturally relate directly to more than one topic. (We all have at least two parents in life, and often have other people who fill the role as well.) These articles, for example, have two main topics, two direct relationships: Obsidian and Personal Knowledge Management. I don’t have to choose one or the other. I might decide to write about information processing, in which case these articles could be given another “parent”, the new topic.\n\n\nInteracting with NoSQL Databases\nThe word graph is commonly used to refer to many different types of charts, such as bar charts or line graphs. It has a more specific meaning, however, which is the specific type of graph produced by Graph View. This is the normal way that these data structures are visualized, which is why Graph View is the ideal way to visually explore our vault. This is also the way neural networks are visualized.\nGetting information from NoSQL databases is done through queries, not by opening documents. Filters in Obsidian Search have all the capabilities of Dataview queries, with a somewhat simpler syntax.\n\n\nFinal words\nI hope I have explained what it means to say that Obsidian is a NoSQL and the implications of that. Everything we write, every word, becomes part of a database, and we can use the power of databases to retrieve information. Stop using Obsidian as a file manager!\n\n\n\n\n Back to top",
    "crumbs": [
      "Obsidian",
      "What does it mean that is a NoSQL Database?"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "This article follows an earlier article introducing DataviewJS, which I strongly encourage you to read first. In that article, we learned how to display basic lists with Dataview. In this article, I will cover displaying lists of files in your vault and information in those files. I will also discuss using date ranges in queries and sorting results. Finally I will show how to make a table with multiple fields.\nAs a refresher, to show a list with a header you typed something like\nconst myList = [\n    \"First\",\n    \"Second\",\n    \"Third\"\n]\n\ndv.header(3, \"My List\")\ndv.list(myList)\n.\nThis creates a variable with a camelCase name. The variable contains a list, surrounded by square brackets, separated by commas, with quotations around strings (text). That was easy.\nNow what if I want to list all the files in my vault? I won’t do this, because the list would be crazy long, but just say I did. I would use\nconst fileNameList = dv.pages().file.name\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nThis would give me a bullet-point list of the names of all of the files in my vault. If you don’t have too many files in your vault, go ahead and try. Before narrowing it down to something more specific, let’s look at what is new here. What is pages().file.name? And for that matter, what’s with all the periods?\nLet me explain the periods first. I said that dv is an object. Objects can contain functions, like list(). They can also contain values, often called attributes. The functions and attributes of any object are referred to or accessed by using the name of the object, followed by a period, and then the name of the function or attribute. So the phrase above means: dv is an object that contains a pages() function (the parentheses let you know it is a function). The pages() function selects certain pages and provides attributes for each page, such as the name, links, date created, date modified, etc., in an object called file. In this case I’m choosing to show just the file name. If I wanted links instead, I would do dv.pages().file.link.\nThis dot-notation, using periods, is actually quite nice when you get used to it. Recall that “white space”, including line breaks, is not important in JavaScript, so you will see me often using line breaks before these periods, purely for readability and ease of editing.\nSo let’s see how to narrow things down a little. For the following examples I will use my exercise logs. All the log files are linked to a file called Logs. I can select files that link to this Logs file by writing pages(\"[[Logs]]\"). Note the quotations AND double square brackets. So I can write:\nconst fileNameList = dv.pages(\"[[Logs]]\").file.link\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nI suggest you create some log files in your vault so that you can follow along. Each file should contain, at least, the following fields, some of which we won’t use until we look at tables:\ntopic:: [[Logs]]\ntype:: log\nActivity:: 🚶\nDuration:: 60\nDistance:: 3\nActivityDate:: 2023-10-05\nI use 🚴 as the other activity type. After creating some log files, and the Logs file itself (this file can be empty for now), go ahead and try the JavaScript. You can use this technique to retrieve files on any topic in this way, assuming you have a topic field with the link (really you only need there to be a link).\n\n\n\nLet’s look at some ways we can modify this snippet to make it more useful. First, if you have tried this, and have created log files with various dates, you may notice that they aren’t necessarily displayed in any particular order. I want to make sure they are ordered by the activity date. The pages() object contains a number of functions allowing us to work with data, and sort() is one. sort() takes two arguments, first the name of the field to sort on, and a second argument specifying the sort order, either \"asc\" or \"desc\", for ascending or descending order, respectively.\nUnfortunately, we can’t just add .sort(ActivityDate, \"desc\"). When working with pages() we need to use a special JavaScript syntax. We need to type .sort(a =&gt; a.ActivityDate, \"desc\"). The letter a is arbitrary. I could also write .sort(foo =&gt; foo.ActivityDate, \"desc\") to achieve the same thing. a, or foo, basically serves as temporary variable name for the object you are working with, in this case the page, or note. Then the command says to use the ActivityDate property on each page for sorting. I know it looks a little confusing at first, but you will see this idiom so frequently you will quickly get used to it.\nSo lets sort our logs by date as so:\nconst fileNameList = dv.pages(\"[[Logs]]\")                                                                                                                \n    .sort(b =&gt; b.ActivityDate, \"desc\")                                                                                                                   \n    .ActivityDate\n\ndv.header(3, \"Activity Dates\")\ndv.list(fileNameList)\nNotice how the dot notation allows us to easily add more conditions to our query. ## Selecting by date\nNext, let’s see how we can select logs only for certain dates. To do that, we use the .where() function supplied by pages(). To see only logs since October 3, 2023, I can write\nconst fileNameList = dv.pages(\"[[Logs]]\")\n  .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .ActivityDate                \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nThe syntax for where() is similar to the syntax for sort(). There is an important difference though, because here we are comparing two values. &gt;= means “greater than or equal to”, &lt;= would be “less than or equal to”, etc. This evaluates to either true or false, since the date is either earlier or later than 10/3. This type of true/false value has a special name, boolean, which is good to know. dv provides its own .date() function for simple date manipulation, and I use it here.\nNow that you know how to use where(), let’s do one more thing with it. The code currently takes advantage of the fact that all the logs are linked to the Logs note. I don’t like that, because I might create some logs with a different topic. You may have noticed that all of the log notes have a type:: log. This can be used with .where(), so I can instead write:\nconst fileNameList = dv.pages()\n .where(b =&gt; b.type == \"log\")\n .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n .sort(b =&gt; b.ActivityDate, \"desc\")\n .ActivityDate\n                                                             \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nMany of my queries are based on the type of note, and this is how the note type can be used. Pay attention to the fact that “equal to” requires two equal signs, not one. For completeness, “not equal to” is written !=.\n\n\n\nLists aren’t very interesting, though. Usually you want more than just the name, or one bit of information from a file. So let’s make a table instead with dv.table(). For tables, you must supply an additional list with the column headers. Then you specify the fields that you want using a JavaScript function called map(). It works pretty much the same way as .sort and .where(), it just has a seemingly odd name. map() is used to go through each item in a list and do something with it, in this case, select certain fields from each note. This is called iteration.\nThis table shows the type of activity, distance in miles, duration in minutes and date. I’ve used emojis for column headings. You can see that the fields I want shown are supplied as a list (between square brackets) of the fields I want in the table.\n\nconst headers = [\"🚶/🚴\", \"🗒️\", \"⏱️\", \"📅\"]\n\nconst pages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .map(b =&gt; [\n        b.Activity, \n        b.Distance, \n        b.Duration, \n        b.ActivityDate\n    ])\n                                \n\ndv.header(3, \"Activity since October 3, 2023\")\ndv.table(headers,   pages)\n\n\n\n\nIn the next article I will look at how to make this table dynamic, allowing you to change values directly in the table. I will also talk about relative dates, eg. activity over the last 10 days, or in the 10 days prior to that, or before a certain day but after another day.\nBefore moving on, I strongly encourage you to work with the material covered so far by adding some metadata to your existing notes and creating some queries. I don’t use tags (for now), but if you do, you could do pages(\"#some/tag\") instead of pages(\"[[Logs]]\"). Maybe you have a tag, #fleeting, for example. You could make a list of all your fleeting notes with pages(#fleeting).\nFinally, if you have been reading my Freeing Your Thinking series you may already be doing these examples on a canvas instead of in a note. If you aren’t I encourage you to do so. You can put the code directly into cards on a canvas. Then you can easily see all of your tables in one place, and convert them into notes if you so desire (but why?). Since the end goal will be to have dashboards to view and manage things, you might as well start now. If you have multiple tables on the same canvas, you might want to increase the Refresh Rate in the Dataview settings to prevent the canvas from being too “jumpy” while you type. The default is 2500ms (2.5 seconds). I find that 5 seconds (5000ms) works pretty well for me and the speed I type.\nHappy coding!",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html#selecting-files",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html#selecting-files",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "This article follows an earlier article introducing DataviewJS, which I strongly encourage you to read first. In that article, we learned how to display basic lists with Dataview. In this article, I will cover displaying lists of files in your vault and information in those files. I will also discuss using date ranges in queries and sorting results. Finally I will show how to make a table with multiple fields.\nAs a refresher, to show a list with a header you typed something like\nconst myList = [\n    \"First\",\n    \"Second\",\n    \"Third\"\n]\n\ndv.header(3, \"My List\")\ndv.list(myList)\n.\nThis creates a variable with a camelCase name. The variable contains a list, surrounded by square brackets, separated by commas, with quotations around strings (text). That was easy.\nNow what if I want to list all the files in my vault? I won’t do this, because the list would be crazy long, but just say I did. I would use\nconst fileNameList = dv.pages().file.name\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nThis would give me a bullet-point list of the names of all of the files in my vault. If you don’t have too many files in your vault, go ahead and try. Before narrowing it down to something more specific, let’s look at what is new here. What is pages().file.name? And for that matter, what’s with all the periods?\nLet me explain the periods first. I said that dv is an object. Objects can contain functions, like list(). They can also contain values, often called attributes. The functions and attributes of any object are referred to or accessed by using the name of the object, followed by a period, and then the name of the function or attribute. So the phrase above means: dv is an object that contains a pages() function (the parentheses let you know it is a function). The pages() function selects certain pages and provides attributes for each page, such as the name, links, date created, date modified, etc., in an object called file. In this case I’m choosing to show just the file name. If I wanted links instead, I would do dv.pages().file.link.\nThis dot-notation, using periods, is actually quite nice when you get used to it. Recall that “white space”, including line breaks, is not important in JavaScript, so you will see me often using line breaks before these periods, purely for readability and ease of editing.\nSo let’s see how to narrow things down a little. For the following examples I will use my exercise logs. All the log files are linked to a file called Logs. I can select files that link to this Logs file by writing pages(\"[[Logs]]\"). Note the quotations AND double square brackets. So I can write:\nconst fileNameList = dv.pages(\"[[Logs]]\").file.link\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nI suggest you create some log files in your vault so that you can follow along. Each file should contain, at least, the following fields, some of which we won’t use until we look at tables:\ntopic:: [[Logs]]\ntype:: log\nActivity:: 🚶\nDuration:: 60\nDistance:: 3\nActivityDate:: 2023-10-05\nI use 🚴 as the other activity type. After creating some log files, and the Logs file itself (this file can be empty for now), go ahead and try the JavaScript. You can use this technique to retrieve files on any topic in this way, assuming you have a topic field with the link (really you only need there to be a link).",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html#sorting",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html#sorting",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "Let’s look at some ways we can modify this snippet to make it more useful. First, if you have tried this, and have created log files with various dates, you may notice that they aren’t necessarily displayed in any particular order. I want to make sure they are ordered by the activity date. The pages() object contains a number of functions allowing us to work with data, and sort() is one. sort() takes two arguments, first the name of the field to sort on, and a second argument specifying the sort order, either \"asc\" or \"desc\", for ascending or descending order, respectively.\nUnfortunately, we can’t just add .sort(ActivityDate, \"desc\"). When working with pages() we need to use a special JavaScript syntax. We need to type .sort(a =&gt; a.ActivityDate, \"desc\"). The letter a is arbitrary. I could also write .sort(foo =&gt; foo.ActivityDate, \"desc\") to achieve the same thing. a, or foo, basically serves as temporary variable name for the object you are working with, in this case the page, or note. Then the command says to use the ActivityDate property on each page for sorting. I know it looks a little confusing at first, but you will see this idiom so frequently you will quickly get used to it.\nSo lets sort our logs by date as so:\nconst fileNameList = dv.pages(\"[[Logs]]\")                                                                                                                \n    .sort(b =&gt; b.ActivityDate, \"desc\")                                                                                                                   \n    .ActivityDate\n\ndv.header(3, \"Activity Dates\")\ndv.list(fileNameList)\nNotice how the dot notation allows us to easily add more conditions to our query. ## Selecting by date\nNext, let’s see how we can select logs only for certain dates. To do that, we use the .where() function supplied by pages(). To see only logs since October 3, 2023, I can write\nconst fileNameList = dv.pages(\"[[Logs]]\")\n  .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .ActivityDate                \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nThe syntax for where() is similar to the syntax for sort(). There is an important difference though, because here we are comparing two values. &gt;= means “greater than or equal to”, &lt;= would be “less than or equal to”, etc. This evaluates to either true or false, since the date is either earlier or later than 10/3. This type of true/false value has a special name, boolean, which is good to know. dv provides its own .date() function for simple date manipulation, and I use it here.\nNow that you know how to use where(), let’s do one more thing with it. The code currently takes advantage of the fact that all the logs are linked to the Logs note. I don’t like that, because I might create some logs with a different topic. You may have noticed that all of the log notes have a type:: log. This can be used with .where(), so I can instead write:\nconst fileNameList = dv.pages()\n .where(b =&gt; b.type == \"log\")\n .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n .sort(b =&gt; b.ActivityDate, \"desc\")\n .ActivityDate\n                                                             \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nMany of my queries are based on the type of note, and this is how the note type can be used. Pay attention to the fact that “equal to” requires two equal signs, not one. For completeness, “not equal to” is written !=.",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html#a-first-table",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html#a-first-table",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "Lists aren’t very interesting, though. Usually you want more than just the name, or one bit of information from a file. So let’s make a table instead with dv.table(). For tables, you must supply an additional list with the column headers. Then you specify the fields that you want using a JavaScript function called map(). It works pretty much the same way as .sort and .where(), it just has a seemingly odd name. map() is used to go through each item in a list and do something with it, in this case, select certain fields from each note. This is called iteration.\nThis table shows the type of activity, distance in miles, duration in minutes and date. I’ve used emojis for column headings. You can see that the fields I want shown are supplied as a list (between square brackets) of the fields I want in the table.\n\nconst headers = [\"🚶/🚴\", \"🗒️\", \"⏱️\", \"📅\"]\n\nconst pages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .map(b =&gt; [\n        b.Activity, \n        b.Distance, \n        b.Duration, \n        b.ActivityDate\n    ])\n                                \n\ndv.header(3, \"Activity since October 3, 2023\")\ndv.table(headers,   pages)",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html#next-steps",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html#next-steps",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "In the next article I will look at how to make this table dynamic, allowing you to change values directly in the table. I will also talk about relative dates, eg. activity over the last 10 days, or in the 10 days prior to that, or before a certain day but after another day.\nBefore moving on, I strongly encourage you to work with the material covered so far by adding some metadata to your existing notes and creating some queries. I don’t use tags (for now), but if you do, you could do pages(\"#some/tag\") instead of pages(\"[[Logs]]\"). Maybe you have a tag, #fleeting, for example. You could make a list of all your fleeting notes with pages(#fleeting).\nFinally, if you have been reading my Freeing Your Thinking series you may already be doing these examples on a canvas instead of in a note. If you aren’t I encourage you to do so. You can put the code directly into cards on a canvas. Then you can easily see all of your tables in one place, and convert them into notes if you so desire (but why?). Since the end goal will be to have dashboards to view and manage things, you might as well start now. If you have multiple tables on the same canvas, you might want to increase the Refresh Rate in the Dataview settings to prevent the canvas from being too “jumpy” while you type. The default is 2500ms (2.5 seconds). I find that 5 seconds (5000ms) works pretty well for me and the speed I type.\nHappy coding!",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/freeing-your-thinking-part-1/index.html",
    "href": "blogs/obsidian/freeing-your-thinking-part-1/index.html",
    "title": "Obsidian: Stop Wasting Time With Directories and Filenames",
    "section": "",
    "text": "The Problem\nBecause we’ve all used computers, when we think of organizing our stuff we naturally think in terms of files and directories, and are aware of the value of descriptive file names. Personally, if I even need to scroll down to see all the files in a single directory, it’s probably time for a subdirectory. And I’m equally unsettled when I see files with meaningless or unclear names. Many people like me explore various systems like PARA, ACCESS, LATCH, etc. to organize our stuff.\nTo be explicit, the stuff referred to here is files. But we use Obsidian for information management, not file management.\nObsidian stores information, but it’s not a database, at least not an SQL database. It is essentially a NoSQL database (more on that in Part 2 and 3). It stores information in text files, but it doesn’t care where the files are nor what they are called. So why should we care?\nI should point out that the word “notes” can mean two different things, really: the file or the information it contains. Decoupling the two meanings, I really only care about the information. The file must exist, of course, but it is not important. What is important is the information in it.\nIf I think in terms of files, I need to spend time thinking about file names and locations, both when recording and retrieving information. I need to navigate to files and directories and/or think about and type out file names. This is all wasted time because, again, the files aren’t important, it’s the information in them that I care about.\nObsidian is powerful and allows us to work with our information in many ways without stopping our flow of thought to worry about files. Stop spending your time in the Navigation pane and start using Search and Bookmarks. That way, you can focus all your attention where it should be, on your information.\n\n\nInformation First\nOk, full disclosure, I do use two directories in my vault, one for templates and one for non-md files. Templates would be impractical to use lumped with all the other files. And attachments aren’t native Obsidian formats and raise other maintenance issues.\nObsidian offers core functionality that allows me to ignore files and focus on information. I’m referring to Search, Bookmarks and Unique Notes. The latter is effectively invisible in articles and videos, and the other two rarely come up. This is especially surprising with regard to Search because that’s the most efficient and powerful way to find information in your vault. Most presenters use Quick Switcher or the Navigator to create and access files in order to create or access information. This is an extra step, wasting time and energy and impeding the flow of thought.\nCtrl-Shft-F is all I need to do to start querying my information. I don’t need to open any files, I just start typing what I’m looking for. If I think I might look for the same or similar information later, I can bookmark the filter.\nWhen I want to write something down, I hit Ctrl-U (I’ve got an assigned hotkey), type my thought, then immediately return to my reading. Again, I don’t have to think about files and directories. It’s that simple, fast, and does not impede my thinking with irrelevant considerations and extra keystrokes.\n\n\nSearch\nSimply typing the word or phrase I’m looking for in the search field will bring up all directly relevant notes on my topic. In case of TMI, I can specify that the terms should be in the same section or the same line. With Hover Editor, I can see the contents of each file listed without opening it, and even modify content directly if I want. I don’t need to actually open a file to get the information I’m looking for, or even modify it.\nSearch filters are just as powerful as Dataview queries. I can use logical AND, OR and NOT, group them with parentheses and sort by modified date. I can include or exclude based on any criteria (WHERE) and specify source (FROM). And I can save the filters as bookmarks. This way I don’t need to have a file that contains a query. The query results don’t “live” in a file, either. I do use Dataview queries frequently to aggregate information that I want to display information in notes. I do not use it to aggregate files that I want to interact with. That’s what Search is for.\n\n\nBookmarks\nI can bookmark files, of course, but I don’t… instead I bookmark sections or blocks (information, not files). I can also bookmark searches and graphs, and organize bookmarks in directories and subdirectories. In most of the videos I see, people have the Navigator panel open “by default”. For me, it’s the bookmarks panel. The Bookmarks panel provides an information tree, the Navigator panel provides a file tree. I want the information tree.\nI can use bookmarks and metadata to mimic directories if I want. My new notes used to go in a certain directory called +, and I had an “Inbox” note with a Dataview query to display the notes. The default template I now apply to every new note contains a field status:: new. I have also bookmarked a search filter “status:: new”. To see all of my new notes, I don’t need to open a directory or go to a file containing a Dataview query. All I need to do is click on the bookmark.\nAny useful search can be bookmarked. I have a bookmark, “action”, for example, which shows all files requiring attention. I always have many bookmarked searches and graphs related to topics I’m focused on, organized in virtual directories.\n\n\nUnique Notes\nMost people are unfamiliar with Unique Notes, even though it is a core plugin. This plugin will generate a new file with a unique name in a pre-defined location and automatically apply a specified template. The idea of randomly-named files dumped in one directory does seem scary, but don’t worry. The default template is, for me at least, entirely metadata. Metadata can be either frontmatter or double-colon in-line style. My template currently looks like this:\n%%\ntopic-ex::\nrelated-ex::\ncreated-ex:: &lt;% tp.date.now(\"YYYY-MM-DD\") %&gt;\nlast edit-ex::\ntype-ex:: article\nstatus-ex:: 0\nsource-ex::\ntitle-ex::\nlink-ex::\naction-ex:: false\n%%\ntopic and related take meaningfully named links, possibly to non-existent files (Obsidian doesn’t care about existence either). type can be atomic, moc, log, etc. Everything else should be self-explanatory. I don’t have to fill any of this in when I’m making notes. I can just jot down the thought and keep reading and thinking. And I can get back to them later by opening my bookmarked “status:: new” search. When I revisit the note to make it atomic, I can fill in the rest of the fields.\nWith this plugin, as I said earlier, I just press Ctrl-U and start writing my information without ever thinking about file names and directories.\nEfficiency Tip: When I’m reading a book or article, knowing I will take several notes in succession from the same source, I temporarily edit the default template to include basic information like source, title, etc. so I don’t have to type what is essentially boilerplate when I process the note and make it atomic.\n\n\nTry it out without commitment\nSince I started with Obsidian, I’ve changed the way I work multiple times. But rarely do I need to “clean up” old notes. For example, as my logging system has evolved, I have left all my old logs and their related Dataview queries in place, adding the newly written queries above them. It just means I have multiple query blocks instead of one in my Exercise Note, for example, but the information displayed remains the same.\nFuller disclosure: I actually have more directories in my vault than just templates and attachments. I used to use the ACCESS directory structure and have many, many notes. When I switched to this information first way, I stopped caring about files, remember, and I didn’t want to start this journey by launching into a massive exercise of moving files around, and adding metadata to all my old notes. That would be unacceptably ironic.\nObsidian is truly a compassionate ally. Very little needs to be done. I had to re-write some queries, as mentioned above. But any Dataview queries which aggregated files instead of information are no longer necessary anyway. For example, my Inbox note that displayed my new notes became irrelevant, since I now have a bookmarked filter, “status:: new”. If directory locations were really important in some queries, just add “(path:old-directory) OR” to your filters.\nYou could just continue to keep your Calendar notes in the same place as you do now, for that matter, or any other plugin that already has directory locations specified in settings. There is no need to be doctrinaire and rigid, after all, since we don’t care about directories anyway. Keep it simple, flexible, and don’t waste time on things that don’t add value.\nFinally, I’ll point out that I didn’t give up on meaningful file names, just at the point of initially writing down an idea. One step in processing a note to ensure its completion and atomicity is to change the name of the file. At the processing stage, choosing a name does not interrupt the flow of thinking, but complements it, since it helps encapsulate an idea and solidify my understanding. It’s just not something to do when making a fleeting note, that’s all. And the name will be useful later.\n\n\nClosing Thoughts\nThis article covers recording and retrieval of information. The second part covers how to analyze and synthesize information with this system.\nI hope I have convinced you at least to give it a try. Obsidian offers so many ways for us to free our thinking and focus on information and flow of thought. Keep the file tree closed, instead use the information tree.\nI am aware that this topic may be controversial because it goes so clearly against most of the approaches proposed on the internet. I do not mean any disrespect to the authors and videographers who have helped and inspired my journey with Obsidian, and to whom I am grateful.\nContinue to Part 2\n\n\n\n\n Back to top",
    "crumbs": [
      "Obsidian",
      "Obsidian: Stop Wasting Time With Directories and Filenames"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "This article is intended for people who are new to programming, but can serve as a jumping off point for experienced programmers new to JavaScript in general or DataviewJS in particular. The documentation can be found here.\nYou may be asking yourself, “Why learn JavaScript since I have Dataview queries to make lists and tables with my data”? You need JavaScript if, for example, you want interactive tables which allow you to edit data directly from the table without opening the associated note (very important in an information-first, NoSQL style). Or if you want to work with relative dates, eg. “last week”, without needing to update your queries every week. JavaScript allows you to show things like totals, counts and averages together with your tables. And since you are writing JavaScript anyway, you can fully customize the way everything is displayed.\nJavaScript may seem intimidating, but it’s really not too complex or complicated for what we need to do in Obsidian. The basic examples I start with here won’t display any tables, but will get you comfortable with some of the basic concepts and how to write simple JavaScript code. It is very important that you do these examples yourself in your own vault. Like any language, the only way to learn it is to use it (and make mistakes).\n\n\nJavaScript is a general purpose programming language not unlike Python, but quite different from the confusingly-named Java programming language to which it bears no relation. It is responsible for most of the dynamic content on the internet. As happens with human languages spoken widely, JavaScript has evolved a variety of “regional dialects”, sharing a common grammar and basic lexicon, but adding words and idioms to work in specific environments. DataviewJS is one such dialect, one which provides a vocabulary specifically tailored for Obsidian. It does this by giving us a Dataview object, but more on that later.\nThis will be a learn-by-example sort of thing, but it’s worth mentioning a few things up front for those totally new to this. In JavaScript, spaces, tabs and line breaks don’t matter. You could write your script on one line, but that would be silly. I suggest that you use spaces and line breaks liberally, because it will make your code much easier to write, read and quickly understand when you look back at it later. You will also see some people using semi-colons at the end of lines. This, too, is optional. Finally, variables can be named however you like, but the convention for multi-word variables is to capitalize the first letter of every word except the first, like theVariableName.\n(Fun fact: this naming convention is called “camel case”, with the capital letters seen as humps protruding from the back of a camel. Two humps can be seen in one form, CamelCase. The form used in JavaScript, camelCase is specifically called “dromedary case” for apparent reasons.)\nOne thing about JavaScript which took me a while to get used to at first was all of the curly braces ({}). All that they indicate is that there is a block of JavaScript code inside, usually with multiple lines. While we’re on the subject of braces, the square brackets ([]) are used when you want a list of things. Just separate each item by commas, and put quotations around each item, like [\"Item 1\", \"Item2\"]. You often want to go through lists item by item (a process called iteration), and we will see later how to do this. Apostrophes (') and quotations (\") can be used interchangeably to wrap text. Don’t worry, we’ll go over all this later.\n\n\n\nThe first program you traditionally write in any programming language is “Hello World”, which displays, not unsurprisingly, “Hello World” as output. Here is such a one in DataviewJS:\ndv.paragraph(\"Hello World\")\nThe output looks like this:\nHello World\nYeah! You are now a JavaScript programmer! This simple example introduces some important concepts, though.\nFirst, when you want to write some JavaScript, you must use a code block with the key word dataviewjs. While you are writing code, it can be convenient to start the code block with js dataviewjs rather than simply dataviewjs. You will get nice syntax highlighting that way, and can simply remove the first js when you want to run your code.\nAs you might have guessed, paragraph just means to display the text in parentheses as a paragraph. Technically, dv.paragraph() is a command, or function, and the part in parentheses is called the arguments. Note the quotations surrounding the text.\nSo what’s this dv thing? Remember when I said that each flavor of JavaScript provides special vocabulary for it’s context? They do this typically by providing an “object” containing the functionality. dv is what is called the Dataview object, and anytime you want to access the functionality of DataviewJS you indicate that by starting your statement or phrase with dv followed by a period. Since displaying a paragraph on a page of markdown is specific to DataviewJS, we write dv.paragraph()\nIn addition to paragraphs, the dv object allows us to display headers, lists, tables, etc. In fact, the dv object can display any HTML element. You can display multiple elements by putting them one after another in your code.\nLet’s look at another example:\ndv.header(2, \"Introduction to DataviewJS\")\ndv.paragraph('\"Hi, my name is DataviewJS\"')\n\n\n\nHi, my name is DataviewJS\nSince it’s hard to show the result naturally, I’ve included screenshots from my vault with the code on the right and the results on the left.\n\nHere I’m displaying 2 elements. Headers require two arguments, the first indicating the header level. This example is the same as writing ## Introduction to DataviewJS. Note that we don’t use quotations around numbers (usually). The dv object also allows us to display lists, like this:\ndv.list([\"Item 1\", \"Item 2\", \"Item 3\"])\nRemember that, when making lists in JavaScript, you use the square brackets and separate each item with a comma. This is also called an array. This is a pretty simple example, but sometimes things get a lot more complicated, and since spaces and new lines don’t matter, it is good practice to write the same code like this:\ndv.list([\n    \"Item 1\",\n    \"Item 2\",\n    \"Item 3\",\n])\nThis makes it much easier to see what is going on, and also makes copying and pasting of individual items easier, too.\n\n\n\nWell, you may not be too impressed so far. Nothing we’ve done yet has been anything we couldn’t have done by simply writing the markdown. Things get more interesting when we start using variables. These allows us to create and manipulate information before displaying it. Variables are usually made (declared) with either const or let in JavaScript. So const myName = \"Brian\" creates a variable called myName with the value of “Brian”. We can then write this:\nconst myName = \"Brian\"\ndv.paragraph(\"Hi, my name is \" + myName + \".\")\nwhich produces\nHi, my name is Brian.\nWhen used with text, called strings in coding lingo, the + puts together (concatenates) multiple strings. You can see that a long string with multiple variables could start to look messy. A more convenient way to combine text and variables is to use back ticks instead of quotes, and put the variable names in curly braces preceded with the dollar sign. So instead we can write:\nconst myName = \"Brian\"\ndv.paragraph(`Hi, my name is ${myName}.`)\nto get the same result.\nYou could still object, no pun intended, that we haven’t done anything we couldn’t have done just by writing out the sentence. We’ll get to that in the next article, but before closing this one, I’ll show you something you can only do with JavaScript. DataviewJS comes with another JavaScript flavor baked in called MomentJS. Like DataviewJS provides a dv object, MomentJS provides a moment object which makes it easy to work with dates and times. We’ll talk a lot more about this later, but for now you can use it like this:\nconst today = moment(Date.now()).format(\"MMMM DD, YYYY\")\ndv.paragraph(`Today is ${today}`)\nToday is October 10, 2023\nThis display’s today’s date in a format specified by argument to the format() function. Every time you open a note or canvas, the current day will be displayed.\nPutting it all together, we can write\nconst myName = \"Brian\"\nconst today = moment(Date.now()).format(\"MMMM DD, YYYY\")\nconst learnings = [\n    \"JavaScript basics\",\n    \"The dataview object\",\n    \"Displaying elements with JavaScript\",\n    \"JavaScript variables\",\n]\ndv.header(3, `Things ${myName} learned on ${today}`)\ndv.list(learnings)\nto produce\n\n\n\nJavaScript basics\nThe dataview object\nDisplaying elements with JavaScript\nJavaScript variables\n\n\n\n\n\n\nIn the next article I’ll start looking at using DataviewJS to make lists and tables and otherwise use the information in your vault. Meanwhile, if you want to learn more about working with dates, you can visit the Moment.js website. And the DataviewJS documentation can be found here. Happy coding!",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#javascript",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#javascript",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "JavaScript is a general purpose programming language not unlike Python, but quite different from the confusingly-named Java programming language to which it bears no relation. It is responsible for most of the dynamic content on the internet. As happens with human languages spoken widely, JavaScript has evolved a variety of “regional dialects”, sharing a common grammar and basic lexicon, but adding words and idioms to work in specific environments. DataviewJS is one such dialect, one which provides a vocabulary specifically tailored for Obsidian. It does this by giving us a Dataview object, but more on that later.\nThis will be a learn-by-example sort of thing, but it’s worth mentioning a few things up front for those totally new to this. In JavaScript, spaces, tabs and line breaks don’t matter. You could write your script on one line, but that would be silly. I suggest that you use spaces and line breaks liberally, because it will make your code much easier to write, read and quickly understand when you look back at it later. You will also see some people using semi-colons at the end of lines. This, too, is optional. Finally, variables can be named however you like, but the convention for multi-word variables is to capitalize the first letter of every word except the first, like theVariableName.\n(Fun fact: this naming convention is called “camel case”, with the capital letters seen as humps protruding from the back of a camel. Two humps can be seen in one form, CamelCase. The form used in JavaScript, camelCase is specifically called “dromedary case” for apparent reasons.)\nOne thing about JavaScript which took me a while to get used to at first was all of the curly braces ({}). All that they indicate is that there is a block of JavaScript code inside, usually with multiple lines. While we’re on the subject of braces, the square brackets ([]) are used when you want a list of things. Just separate each item by commas, and put quotations around each item, like [\"Item 1\", \"Item2\"]. You often want to go through lists item by item (a process called iteration), and we will see later how to do this. Apostrophes (') and quotations (\") can be used interchangeably to wrap text. Don’t worry, we’ll go over all this later.",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#hello-world",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#hello-world",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "The first program you traditionally write in any programming language is “Hello World”, which displays, not unsurprisingly, “Hello World” as output. Here is such a one in DataviewJS:\ndv.paragraph(\"Hello World\")\nThe output looks like this:\nHello World\nYeah! You are now a JavaScript programmer! This simple example introduces some important concepts, though.\nFirst, when you want to write some JavaScript, you must use a code block with the key word dataviewjs. While you are writing code, it can be convenient to start the code block with js dataviewjs rather than simply dataviewjs. You will get nice syntax highlighting that way, and can simply remove the first js when you want to run your code.\nAs you might have guessed, paragraph just means to display the text in parentheses as a paragraph. Technically, dv.paragraph() is a command, or function, and the part in parentheses is called the arguments. Note the quotations surrounding the text.\nSo what’s this dv thing? Remember when I said that each flavor of JavaScript provides special vocabulary for it’s context? They do this typically by providing an “object” containing the functionality. dv is what is called the Dataview object, and anytime you want to access the functionality of DataviewJS you indicate that by starting your statement or phrase with dv followed by a period. Since displaying a paragraph on a page of markdown is specific to DataviewJS, we write dv.paragraph()\nIn addition to paragraphs, the dv object allows us to display headers, lists, tables, etc. In fact, the dv object can display any HTML element. You can display multiple elements by putting them one after another in your code.\nLet’s look at another example:\ndv.header(2, \"Introduction to DataviewJS\")\ndv.paragraph('\"Hi, my name is DataviewJS\"')",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#introduction-to-dataviewjs",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#introduction-to-dataviewjs",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "Hi, my name is DataviewJS\nSince it’s hard to show the result naturally, I’ve included screenshots from my vault with the code on the right and the results on the left.\n\nHere I’m displaying 2 elements. Headers require two arguments, the first indicating the header level. This example is the same as writing ## Introduction to DataviewJS. Note that we don’t use quotations around numbers (usually). The dv object also allows us to display lists, like this:\ndv.list([\"Item 1\", \"Item 2\", \"Item 3\"])\nRemember that, when making lists in JavaScript, you use the square brackets and separate each item with a comma. This is also called an array. This is a pretty simple example, but sometimes things get a lot more complicated, and since spaces and new lines don’t matter, it is good practice to write the same code like this:\ndv.list([\n    \"Item 1\",\n    \"Item 2\",\n    \"Item 3\",\n])\nThis makes it much easier to see what is going on, and also makes copying and pasting of individual items easier, too.",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#variables",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#variables",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "Well, you may not be too impressed so far. Nothing we’ve done yet has been anything we couldn’t have done by simply writing the markdown. Things get more interesting when we start using variables. These allows us to create and manipulate information before displaying it. Variables are usually made (declared) with either const or let in JavaScript. So const myName = \"Brian\" creates a variable called myName with the value of “Brian”. We can then write this:\nconst myName = \"Brian\"\ndv.paragraph(\"Hi, my name is \" + myName + \".\")\nwhich produces\nHi, my name is Brian.\nWhen used with text, called strings in coding lingo, the + puts together (concatenates) multiple strings. You can see that a long string with multiple variables could start to look messy. A more convenient way to combine text and variables is to use back ticks instead of quotes, and put the variable names in curly braces preceded with the dollar sign. So instead we can write:\nconst myName = \"Brian\"\ndv.paragraph(`Hi, my name is ${myName}.`)\nto get the same result.\nYou could still object, no pun intended, that we haven’t done anything we couldn’t have done just by writing out the sentence. We’ll get to that in the next article, but before closing this one, I’ll show you something you can only do with JavaScript. DataviewJS comes with another JavaScript flavor baked in called MomentJS. Like DataviewJS provides a dv object, MomentJS provides a moment object which makes it easy to work with dates and times. We’ll talk a lot more about this later, but for now you can use it like this:\nconst today = moment(Date.now()).format(\"MMMM DD, YYYY\")\ndv.paragraph(`Today is ${today}`)\nToday is October 10, 2023\nThis display’s today’s date in a format specified by argument to the format() function. Every time you open a note or canvas, the current day will be displayed.\nPutting it all together, we can write\nconst myName = \"Brian\"\nconst today = moment(Date.now()).format(\"MMMM DD, YYYY\")\nconst learnings = [\n    \"JavaScript basics\",\n    \"The dataview object\",\n    \"Displaying elements with JavaScript\",\n    \"JavaScript variables\",\n]\ndv.header(3, `Things ${myName} learned on ${today}`)\ndv.list(learnings)\nto produce\n\n\n\nJavaScript basics\nThe dataview object\nDisplaying elements with JavaScript\nJavaScript variables",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#next-steps",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#next-steps",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "In the next article I’ll start looking at using DataviewJS to make lists and tables and otherwise use the information in your vault. Meanwhile, if you want to learn more about working with dates, you can visit the Moment.js website. And the DataviewJS documentation can be found here. Happy coding!",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "This article follows up on earlier articles in which I showed how to create interactive tables which are automatically updated and can be edited directly in the table. This article will describe how to create summary statistics for data. The statistics on the dashboard update based on the current day.\nAs you can see, I’ve done a bit of rearranging since the last article to make things even more readable. The statistics tables have been re-sized and reformatted for a cleaner display, and I’ve added more information. There are still some tweaks I want to do, but this is a very useful dashboard.\nA quick comment on canvases: since I started working on canvases it’s hard to go back to the 80 characters wide format of a note. Sure, when I’m writing an article or focusing on a bit of code, that format feels very natural. But when doing pretty much anything else, well, it’s just nice to be able to spread out, and not have to open and close files, or page up and down through documents. Using a canvas is like putting all of your current work on your desk, with everything open to the pages you are interested in. In a future article I will show how a dashboard can be used in place of a Daily Note to manage your day.\nHere is the table I will show how to create in this article. As before, you can just skip to the bottom and grab the code if you want. This article explains everything rather thoroughly and introduces some general programming concepts. I think that, if you spend a little time with the material you will find that it is not, as they say, rocket science.\n\nThat’s 22 numbers to calculate! The process isn’t too complicated, but we need to keep track of a lot of things. To avoid a lot of repetition, we will create some custom functions, and you need to learn how to “push” lists into lists.\nLet’s start by writing down what we need to do.\n\nCreate the data sets\n\nGet the logs for current and prior periods\nSeparate by activity\n\nMake a variable and calculate each statistic for current and prior periods\n\ndistance for each activity and total (6 total)\nduration for each activity and total (6 total)\nspeed for each activity (4 total)\ncounts for each activity (6 total)\n\nGenerate the output\n\nCreate the tables’ headers\nGenerate the table rows\nCreate headers for the with workout totals\nDisplay the tables with header elements\n\n\n\n\nFirst, let’s grab the data for the current and prior seven day periods. In the last article I showed how to get the current period. Did you figure out how to get the prior period? One way is to first take the data from the last 14 days, and then remove the most recent 7 days. So we’ll do it like this:\nconst priorPages = dv.pages() \n                    .where(b =&gt; b.type == \"log\")\n                    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n                    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \n\nCreate the currentPages data set as well. Then each needs to be separated by walking and biking. You can do it like this:\nconst currentWalkPages = currentPages\n                    .where(b =&gt; b.Activity == \"🚶\")\nGo ahead and create the rest of the datasets. You need currentBikePages, priorWalkPages and priorBikePages.\n\n\n\nGood programming involves avoiding repetitive tasks. Whenever you need to do the same thing more than once or twice, the standard practice is to make a function.\n\n\nHere is an example of a function we can use. It is arguably overkill to make this a function, but it will provide a good example. A function starts with the keyword function followed by the name you want to use. The name is followed by parentheses which are required, but may be empty. They are used to pass arguments to the function. The function itself is then placed in curly braces. After the function does it’s work, it needs to return some value.\nI have a bunch of numbers in minutes which I want to convert to hours. This is just a matter of dividing by 60 of course, but I also want to round off to one decimal. There is a function toFixed() which can be used on strings. It takes one argument, the number of decimal places you want to round it to. This is the function:\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\nand I use it like this.\nconst totalCurrentTime = toHours( sumStat(\"duration\", pages) )\nOf course, I haven’t created sumStat() yet. To calculate the sum there is a JavaScript function called reduce(). It is used like this:\nreduce(\n    (sum, b) =&gt; sum + b.Distance,\n     0\n)\nThe syntax looks a little complicated, but it’s not so bad if you break it down. reduce() takes two arguments. The first argument is (sum, b) =&gt; sum + b.Distance, which is itself a function with two arguments. The second argument here is our old friend b. In this case, we also need temporary variable called an accumulator. The name of this variable is arbitrary, like b. reduce() will go through each log, adding the value of the Distance field to the accumulator. The second argument to reduce() is just the initial value for the accumulator, which is almost always 0.\nNow I can write the function like this\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    \n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\nI didn’t want to write two separate functions for calculating the sums, instead I use a conditional if statement, which works as you might expect. Notice a few things about this. First, pageValues just saves us adding .values to each if statement. if statements require a condition in parentheses. It must be something that evaluates to a boolean value (true or false, remember). Then, as usual, the block of code you want to execute must be in curly braces. Finally, you almost always want to return something. Once you hit a return statement, nothing else gets executed in the function.\n\n\n\nNow we can create all of our time and distance variables like this:\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\nSpeed is just distance over time, so.\nconst currentWalkSpeed = (\n    totalCurrentWalkDistance / totalCurrentWalkTime\n    )\n    .toFixed(1)\nNotice that I specified to round to one decimal point. To find the total number of workouts it is necessary merely to count the number of pages in each category, since each represents one workout. pages() is a list, or array. Arrays all have an attribute/property called length. So to count all workouts in the last seven days I can just write const currentCount = currentPages.length.\nEverything else is just repetition, since we need 22 values at the end of the day. Any repetitive activity cries out for a new function to encapsulate this repetition, but I’ll leave that for another day. (This is called refactoring.)\n\n\n\n\nThe tables from the last article used a dv.pages() object for the table rows. This time I need to create each table row myself. Each table row is itself a list. So I need a list of lists. It is easy to do this with the push() command, which just adds an item to a list. The item being added can be anything, including a list. I will build the table rows like this:\nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nI have to initialize the variable, because I can’t push anything onto a non-existent list. I used let instead of const. The difference is that a const variable cannot change after it has been created, while one declared with var can. (In older code you will see var instead of let. This still works but let is preferred.)\nSo all that remains is to push each row of the table into the rows variable, create the headers for the table, and use dv.table() to display it. The final code is at the bottom. I strongly suggest, having reached this point, that you try to do this on your own and don’t simply copy and paste my code.\n\n\n\nIf you read through both articles, congratulations. Give yourself a pat on the back. You are doing object-oriented programming in the most widely-used language on the internet. And you have all of the knowledge you need to create rich, useful dashboards.\nHappy coding!\n/* Create data sets  */\n\nconst currentPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\nconst priorPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \nconst currentWalkPages = currentPages\n    .where(b =&gt; b.Activity == \"🚶\")\nconst currentBikePages = currentPages\n    .where(b =&gt; b.Activity == \"🚴\")\nconst priorWalkPages = priorPages\n    .where(b =&gt; b.Activity == \"🚶\")\nconst priorBikePages = priorPages\n    .where(b =&gt; b.Activity == \"🚴\")\n\n/* Function to sum the distances, duration */\n\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    \n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\n\n/* Function to convert minutes to hours */\n\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\n\n\n/* Calculate the distances (6 values) */\n\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\n\nconst totalCurrentWalkDistance = sumStat(\"distance\",currentWalkPages).toFixed(1)\nconst totalCurrentBikeDistance = sumStat(\"distance\", currentBikePages).toFixed(1)\nconst totalPriorDistance = sumStat(\"distance\",priorPages).toFixed(1)\nconst totalPriorWalkDistance = sumStat(\"distance\",priorWalkPages).toFixed(1)\nconst totalPriorBikeDistance = sumStat(\"distance\",priorBikePages).toFixed(1)\n\n/* Calculate the durations (6 values) */\n\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\n\nconst totalCurrentWalkTime = toHours(sumStat(\"duration\",currentWalkPages))\nconst totalCurrentBikeTime = toHours(sumStat(\"duration\",currentBikePages))\nconst totalPriorTime = toHours(sumStat(\"duration\",priorPages))\nconst totalPriorWalkTime = toHours(sumStat(\"duration\",priorWalkPages))\nconst totalPriorBikeTime = toHours(sumStat(\"duration\",priorBikePages))\n\n/* Calculate the speed (4 values) */\n\nconst currentWalkSpeed = (totalCurrentWalkDistance / totalCurrentWalkTime).toFixed(1)\nconst priorWalkSpeed = (totalPriorWalkDistance / totalPriorWalkTime).toFixed(1)\nconst currentBikeSpeed = (totalCurrentBikeDistance / totalCurrentBikeTime).toFixed(1)\nconst priorBikeSpeed = (totalPriorBikeDistance / totalPriorBikeTime).toFixed(1)\n\n/* Count the workouts */\n\nconst currentCount = currentPages.length\nconst priorCount = priorPages.length\nconst currentBikeCount = currentBikePages.length\nconst priorBikeCount = priorBikePages.length\nconst currentWalkCount = currentWalkPages.length\nconst priorWalkCount = priorWalkPages.length\n\n\n\n/* Create an array (list) and add the table rows\n   The first table displays the distance and duration */\n   \nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nrows.push([\"🚶\", totalCurrentWalkDistance, totalPriorWalkDistance])\nrows.push([\"🚴\", totalCurrentBikeDistance, totalPriorBikeDistance])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Hours\", totalCurrentTime, totalPriorTime])\nrows.push([\"🚶\", totalCurrentWalkTime, totalPriorWalkTime])\nrows.push([\"🚴\", totalCurrentBikeTime, totalPriorBikeTime])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Speed (m/h)\", \"\", \"\"])\nrows.push([\"🚶\", currentWalkSpeed, priorWalkSpeed])\nrows.push([\"🚴\", currentBikeSpeed, priorBikeSpeed])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Workouts\", currentCount, priorCount])\nrows.push([\"🚶\", currentWalkCount, priorWalkCount])\nrows.push([\"🚴\", currentBikeCount, priorBikeCount])\n\n/* Create the table header */\n\nconst tableHeader = [\"\",\"Current\",\"Prior\"]\n\n/* Display the table */\n\ndv.header(3, \"7 Day Stats\")\ndv.table(tableHeader, rows)",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#the-data",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#the-data",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "First, let’s grab the data for the current and prior seven day periods. In the last article I showed how to get the current period. Did you figure out how to get the prior period? One way is to first take the data from the last 14 days, and then remove the most recent 7 days. So we’ll do it like this:\nconst priorPages = dv.pages() \n                    .where(b =&gt; b.type == \"log\")\n                    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n                    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \n\nCreate the currentPages data set as well. Then each needs to be separated by walking and biking. You can do it like this:\nconst currentWalkPages = currentPages\n                    .where(b =&gt; b.Activity == \"🚶\")\nGo ahead and create the rest of the datasets. You need currentBikePages, priorWalkPages and priorBikePages.",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#calculations",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#calculations",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "Good programming involves avoiding repetitive tasks. Whenever you need to do the same thing more than once or twice, the standard practice is to make a function.\n\n\nHere is an example of a function we can use. It is arguably overkill to make this a function, but it will provide a good example. A function starts with the keyword function followed by the name you want to use. The name is followed by parentheses which are required, but may be empty. They are used to pass arguments to the function. The function itself is then placed in curly braces. After the function does it’s work, it needs to return some value.\nI have a bunch of numbers in minutes which I want to convert to hours. This is just a matter of dividing by 60 of course, but I also want to round off to one decimal. There is a function toFixed() which can be used on strings. It takes one argument, the number of decimal places you want to round it to. This is the function:\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\nand I use it like this.\nconst totalCurrentTime = toHours( sumStat(\"duration\", pages) )\nOf course, I haven’t created sumStat() yet. To calculate the sum there is a JavaScript function called reduce(). It is used like this:\nreduce(\n    (sum, b) =&gt; sum + b.Distance,\n     0\n)\nThe syntax looks a little complicated, but it’s not so bad if you break it down. reduce() takes two arguments. The first argument is (sum, b) =&gt; sum + b.Distance, which is itself a function with two arguments. The second argument here is our old friend b. In this case, we also need temporary variable called an accumulator. The name of this variable is arbitrary, like b. reduce() will go through each log, adding the value of the Distance field to the accumulator. The second argument to reduce() is just the initial value for the accumulator, which is almost always 0.\nNow I can write the function like this\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    \n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\nI didn’t want to write two separate functions for calculating the sums, instead I use a conditional if statement, which works as you might expect. Notice a few things about this. First, pageValues just saves us adding .values to each if statement. if statements require a condition in parentheses. It must be something that evaluates to a boolean value (true or false, remember). Then, as usual, the block of code you want to execute must be in curly braces. Finally, you almost always want to return something. Once you hit a return statement, nothing else gets executed in the function.\n\n\n\nNow we can create all of our time and distance variables like this:\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\nSpeed is just distance over time, so.\nconst currentWalkSpeed = (\n    totalCurrentWalkDistance / totalCurrentWalkTime\n    )\n    .toFixed(1)\nNotice that I specified to round to one decimal point. To find the total number of workouts it is necessary merely to count the number of pages in each category, since each represents one workout. pages() is a list, or array. Arrays all have an attribute/property called length. So to count all workouts in the last seven days I can just write const currentCount = currentPages.length.\nEverything else is just repetition, since we need 22 values at the end of the day. Any repetitive activity cries out for a new function to encapsulate this repetition, but I’ll leave that for another day. (This is called refactoring.)",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#generate-the-output",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#generate-the-output",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "The tables from the last article used a dv.pages() object for the table rows. This time I need to create each table row myself. Each table row is itself a list. So I need a list of lists. It is easy to do this with the push() command, which just adds an item to a list. The item being added can be anything, including a list. I will build the table rows like this:\nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nI have to initialize the variable, because I can’t push anything onto a non-existent list. I used let instead of const. The difference is that a const variable cannot change after it has been created, while one declared with var can. (In older code you will see var instead of let. This still works but let is preferred.)\nSo all that remains is to push each row of the table into the rows variable, create the headers for the table, and use dv.table() to display it. The final code is at the bottom. I strongly suggest, having reached this point, that you try to do this on your own and don’t simply copy and paste my code.",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#final-thoughts",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#final-thoughts",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "If you read through both articles, congratulations. Give yourself a pat on the back. You are doing object-oriented programming in the most widely-used language on the internet. And you have all of the knowledge you need to create rich, useful dashboards.\nHappy coding!\n/* Create data sets  */\n\nconst currentPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\nconst priorPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \nconst currentWalkPages = currentPages\n    .where(b =&gt; b.Activity == \"🚶\")\nconst currentBikePages = currentPages\n    .where(b =&gt; b.Activity == \"🚴\")\nconst priorWalkPages = priorPages\n    .where(b =&gt; b.Activity == \"🚶\")\nconst priorBikePages = priorPages\n    .where(b =&gt; b.Activity == \"🚴\")\n\n/* Function to sum the distances, duration */\n\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    \n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\n\n/* Function to convert minutes to hours */\n\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\n\n\n/* Calculate the distances (6 values) */\n\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\n\nconst totalCurrentWalkDistance = sumStat(\"distance\",currentWalkPages).toFixed(1)\nconst totalCurrentBikeDistance = sumStat(\"distance\", currentBikePages).toFixed(1)\nconst totalPriorDistance = sumStat(\"distance\",priorPages).toFixed(1)\nconst totalPriorWalkDistance = sumStat(\"distance\",priorWalkPages).toFixed(1)\nconst totalPriorBikeDistance = sumStat(\"distance\",priorBikePages).toFixed(1)\n\n/* Calculate the durations (6 values) */\n\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\n\nconst totalCurrentWalkTime = toHours(sumStat(\"duration\",currentWalkPages))\nconst totalCurrentBikeTime = toHours(sumStat(\"duration\",currentBikePages))\nconst totalPriorTime = toHours(sumStat(\"duration\",priorPages))\nconst totalPriorWalkTime = toHours(sumStat(\"duration\",priorWalkPages))\nconst totalPriorBikeTime = toHours(sumStat(\"duration\",priorBikePages))\n\n/* Calculate the speed (4 values) */\n\nconst currentWalkSpeed = (totalCurrentWalkDistance / totalCurrentWalkTime).toFixed(1)\nconst priorWalkSpeed = (totalPriorWalkDistance / totalPriorWalkTime).toFixed(1)\nconst currentBikeSpeed = (totalCurrentBikeDistance / totalCurrentBikeTime).toFixed(1)\nconst priorBikeSpeed = (totalPriorBikeDistance / totalPriorBikeTime).toFixed(1)\n\n/* Count the workouts */\n\nconst currentCount = currentPages.length\nconst priorCount = priorPages.length\nconst currentBikeCount = currentBikePages.length\nconst priorBikeCount = priorBikePages.length\nconst currentWalkCount = currentWalkPages.length\nconst priorWalkCount = priorWalkPages.length\n\n\n\n/* Create an array (list) and add the table rows\n   The first table displays the distance and duration */\n   \nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nrows.push([\"🚶\", totalCurrentWalkDistance, totalPriorWalkDistance])\nrows.push([\"🚴\", totalCurrentBikeDistance, totalPriorBikeDistance])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Hours\", totalCurrentTime, totalPriorTime])\nrows.push([\"🚶\", totalCurrentWalkTime, totalPriorWalkTime])\nrows.push([\"🚴\", totalCurrentBikeTime, totalPriorBikeTime])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Speed (m/h)\", \"\", \"\"])\nrows.push([\"🚶\", currentWalkSpeed, priorWalkSpeed])\nrows.push([\"🚴\", currentBikeSpeed, priorBikeSpeed])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Workouts\", currentCount, priorCount])\nrows.push([\"🚶\", currentWalkCount, priorWalkCount])\nrows.push([\"🚴\", currentBikeCount, priorBikeCount])\n\n/* Create the table header */\n\nconst tableHeader = [\"\",\"Current\",\"Prior\"]\n\n/* Display the table */\n\ndv.header(3, \"7 Day Stats\")\ndv.table(tableHeader, rows)",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "obsidian.html",
    "href": "obsidian.html",
    "title": "Obsidian",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nMar 20, 2024\n\n\nObsidian and Jupyter Notebooks\n\n\nBrian Carey\n\n\n\n\nFeb 28, 2024\n\n\nDataviewJS: A Gentle Introduction Part 2\n\n\nBrian Carey\n\n\n\n\nJan 19, 2024\n\n\nGit and GitHub for Obsidian Users\n\n\nBrian Carey\n\n\n\n\nOct 16, 2023\n\n\nSummarizing Information with DataviewJS\n\n\nBrian Carey\n\n\n\n\nOct 14, 2023\n\n\nInteractive Tables with DataviewJS\n\n\nBrian Carey\n\n\n\n\nOct 11, 2023\n\n\nDataviewJS: A Gentle Introduction\n\n\nBrian Carey\n\n\n\n\nSep 21, 2023\n\n\nObsidian: Freeing Your Thinking Workflow\n\n\nBrian Carey\n\n\n\n\nSep 6, 2023\n\n\nObsidian Metadata Menu Plugin\n\n\nBrian Carey\n\n\n\n\nSep 5, 2023\n\n\nObsidian Bookmarks\n\n\nBrian Carey\n\n\n\n\nAug 31, 2023\n\n\nObsidian: The mechanics of Graph View\n\n\nBrian Carey\n\n\n\n\nAug 27, 2023\n\n\nObsidian Basics - Headers\n\n\nBrian Carey\n\n\n\n\nAug 24, 2023\n\n\nWhat does it mean that is a NoSQL Database?\n\n\nBrian Carey\n\n\n\n\nAug 24, 2023\n\n\nObsidian: Stop Wasting Time With Directories and Filenames\n\n\nBrian Carey\n\n\n\n\nAug 24, 2023\n\n\nObsidian: Meaningless Names, No Directories, Now What?\n\n\nBrian Carey\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Home",
      "Obsidian"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "biscotty's Workshop",
    "section": "",
    "text": "For the love of learning\n\nI’ll write some intro material here. I’ll write some intro material here. I’ll write some intro material here.\nObsidian Articles\nData Science Articles\nCheck out the current workshop.\nThanks to (Shanny-Csik 2022)\n\n\n\n Back to topReferences\n\nShanny-Csik, Samantha. 2022. “Adding a Blog to Your Existing Quarto Website.” October 24, 2022. https://samanthacsik.github.io/posts/2022-10-24-quarto-blogs/."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "All my favoriate resources",
    "section": "",
    "text": "Back to top"
  }
]