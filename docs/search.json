[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "biscotty's Workshop",
    "section": "",
    "text": "For the love of learning\n\nI‚Äôll write some intro material here. I‚Äôll write some intro material here. I‚Äôll write some intro material here.\nCheck out the current workshop.\nThanks to (Shanny-Csik 2022)\n\n\n\n Back to topReferences\n\nShanny-Csik, Samantha. 2022. ‚ÄúAdding a Blog to Your Existing Quarto Website.‚Äù October 24, 2022. https://samanthacsik.github.io/posts/2022-10-24-quarto-blogs/."
  },
  {
    "objectID": "data-science.html",
    "href": "data-science.html",
    "title": "Data Science",
    "section": "",
    "text": "Trail Mapping with Python\n\n\n\n\n\n\nGIS\n\n\nPython\n\n\nData Science\n\n\n\nUsing your GPX data with geopandas\n\n\n\n\n\nFeb 28, 2024\n\n\nBrian Carey\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "Posts",
    "section": "",
    "text": "Trail Mapping with Python\n\n\n\n\n\n\nGIS\n\n\nPython\n\n\nData Science\n\n\n\nUsing your GPX data with geopandas\n\n\n\n\n\nFeb 28, 2024\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nDataviewJS: A Gentle Introduction Part 2\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nSelecting Files, Working with Dates\n\n\n\n\n\nFeb 28, 2024\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nSummarizing Information with DataviewJS\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nPresenting and analyzing information in Obsidian\n\n\n\n\n\nOct 16, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive Tables with DataviewJS\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nSelecting Files, Working with Dates\n\n\n\n\n\nOct 14, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nDataviewJS: A Gentle Introduction\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nFor Obsidian users who are not programmers\n\n\n\n\n\nOct 11, 2023\n\n\nBrian Carey\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "This article is intended for people who are new to programming, but can serve as a jumping off point for experienced programmers new to JavaScript in general or DataviewJS in particular. The documentation can be found here.\nYou may be asking yourself, ‚ÄúWhy learn JavaScript since I have Dataview queries to make lists and tables with my data‚Äù? You need JavaScript if, for example, you want interactive tables which allow you to edit data directly from the table without opening the associated note (very important in an information-first, NoSQL style). Or if you want to work with relative dates, eg. ‚Äúlast week‚Äù, without needing to update your queries every week. JavaScript allows you to show things like totals, counts and averages together with your tables. And since you are writing JavaScript anyway, you can fully customize the way everything is displayed.\nJavaScript may seem intimidating, but it‚Äôs really not too complex or complicated for what we need to do in Obsidian. The basic examples I start with here won‚Äôt display any tables, but will get you comfortable with some of the basic concepts and how to write simple JavaScript code. It is very important that you do these examples yourself in your own vault. Like any language, the only way to learn it is to use it (and make mistakes).\n\n\nJavaScript is a general purpose programming language not unlike Python, but quite different from the confusingly-named Java programming language to which it bears no relation. It is responsible for most of the dynamic content on the internet. As happens with human languages spoken widely, JavaScript has evolved a variety of ‚Äúregional dialects‚Äù, sharing a common grammar and basic lexicon, but adding words and idioms to work in specific environments. DataviewJS is one such dialect, one which provides a vocabulary specifically tailored for Obsidian. It does this by giving us a Dataview object, but more on that later.\nThis will be a learn-by-example sort of thing, but it‚Äôs worth mentioning a few things up front for those totally new to this. In JavaScript, spaces, tabs and line breaks don‚Äôt matter. You could write your script on one line, but that would be silly. I suggest that you use spaces and line breaks liberally, because it will make your code much easier to write, read and quickly understand when you look back at it later. You will also see some people using semi-colons at the end of lines. This, too, is optional. Finally, variables can be named however you like, but the convention for multi-word variables is to capitalize the first letter of every word except the first, like theVariableName.\n(Fun fact: this naming convention is called ‚Äúcamel case‚Äù, with the capital letters seen as humps protruding from the back of a camel. Two humps can be seen in one form, CamelCase. The form used in JavaScript, camelCase is specifically called ‚Äúdromedary case‚Äù for apparent reasons.)\nOne thing about JavaScript which took me a while to get used to at first was all of the curly braces ({}). All that they indicate is that there is a block of JavaScript code inside, usually with multiple lines. While we‚Äôre on the subject of braces, the square brackets ([]) are used when you want a list of things. Just separate each item by commas, and put quotations around each item, like [\"Item 1\", \"Item2\"]. You often want to go through lists item by item (a process called iteration), and we will see later how to do this. Apostrophes (') and quotations (\") can be used interchangeably to wrap text. Don‚Äôt worry, we‚Äôll go over all this later.\n\n\n\nThe first program you traditionally write in any programming language is ‚ÄúHello World‚Äù, which displays, not unsurprisingly, ‚ÄúHello World‚Äù as output. Here is such a one in DataviewJS:\ndv.paragraph(\"Hello World\")\nThe output looks like this:\nHello World\nYeah! You are now a JavaScript programmer! This simple example introduces some important concepts, though.\nFirst, when you want to write some JavaScript, you must use a code block with the key word dataviewjs. While you are writing code, it can be convenient to start the code block with js dataviewjs rather than simply dataviewjs. You will get nice syntax highlighting that way, and can simply remove the first js when you want to run your code.\nAs you might have guessed, paragraph just means to display the text in parentheses as a paragraph. Technically, dv.paragraph() is a command, or function, and the part in parentheses is called the arguments. Note the quotations surrounding the text.\nSo what‚Äôs this dv thing? Remember when I said that each flavor of JavaScript provides special vocabulary for it‚Äôs context? They do this typically by providing an ‚Äúobject‚Äù containing the functionality. dv is what is called the Dataview object, and anytime you want to access the functionality of DataviewJS you indicate that by starting your statement or phrase with dv followed by a period. Since displaying a paragraph on a page of markdown is specific to DataviewJS, we write dv.paragraph()\nIn addition to paragraphs, the dv object allows us to display headers, lists, tables, etc. In fact, the dv object can display any HTML element. You can display multiple elements by putting them one after another in your code.\nLet‚Äôs look at another example:\ndv.header(2, \"Introduction to DataviewJS\")\ndv.paragraph('\"Hi, my name is DataviewJS\"')\n\n\n\nHi, my name is DataviewJS\nSince it‚Äôs hard to show the result naturally, I‚Äôve included screenshots from my vault with the code on the right and the results on the left.\n\nHere I‚Äôm displaying 2 elements. Headers require two arguments, the first indicating the header level. This example is the same as writing ## Introduction to DataviewJS. Note that we don‚Äôt use quotations around numbers (usually). The dv object also allows us to display lists, like this:\ndv.list([\"Item 1\", \"Item 2\", \"Item 3\"])\nRemember that, when making lists in JavaScript, you use the square brackets and separate each item with a comma. This is also called an array. This is a pretty simple example, but sometimes things get a lot more complicated, and since spaces and new lines don‚Äôt matter, it is good practice to write the same code like this:\ndv.list([\n    \"Item 1\",\n    \"Item 2\",\n    \"Item 3\",\n])\nThis makes it much easier to see what is going on, and also makes copying and pasting of individual items easier, too.\n\n\n\nWell, you may not be too impressed so far. Nothing we‚Äôve done yet has been anything we couldn‚Äôt have done by simply writing the markdown. Things get more interesting when we start using variables. These allows us to create and manipulate information before displaying it. Variables are usually made (declared) with either const or let in JavaScript. So const myName = \"Brian\" creates a variable called myName with the value of ‚ÄúBrian‚Äù. We can then write this:\nconst myName = \"Brian\"\ndv.paragraph(\"Hi, my name is \" + myName + \".\")\nwhich produces\nHi, my name is Brian.\nWhen used with text, called strings in coding lingo, the + puts together (concatenates) multiple strings. You can see that a long string with multiple variables could start to look messy. A more convenient way to combine text and variables is to use back ticks instead of quotes, and put the variable names in curly braces preceded with the dollar sign. So instead we can write:\nconst myName = \"Brian\"\ndv.paragraph(`Hi, my name is ${myName}.`)\nto get the same result.\nYou could still object, no pun intended, that we haven‚Äôt done anything we couldn‚Äôt have done just by writing out the sentence. We‚Äôll get to that in the next article, but before closing this one, I‚Äôll show you something you can only do with JavaScript. DataviewJS comes with another JavaScript flavor baked in called MomentJS. Like DataviewJS provides a dv object, MomentJS provides a moment object which makes it easy to work with dates and times. We‚Äôll talk a lot more about this later, but for now you can use it like this:\nconst today = moment(Date.now()).format(\"MMMM DD, YYYY\")\ndv.paragraph(`Today is ${today}`)\nToday is October 10, 2023\nThis display‚Äôs today‚Äôs date in a format specified by argument to the format() function. Every time you open a note or canvas, the current day will be displayed.\nPutting it all together, we can write\nconst myName = \"Brian\"\nconst today = moment(Date.now()).format(\"MMMM DD, YYYY\")\nconst learnings = [\n    \"JavaScript basics\",\n    \"The dataview object\",\n    \"Displaying elements with JavaScript\",\n    \"JavaScript variables\",\n]\ndv.header(3, `Things ${myName} learned on ${today}`)\ndv.list(learnings)\nto produce\n\n\n\nJavaScript basics\nThe dataview object\nDisplaying elements with JavaScript\nJavaScript variables\n\n\n\n\n\n\nIn the next article I‚Äôll start looking at using DataviewJS to make lists and tables and otherwise use the information in your vault. Meanwhile, if you want to learn more about working with dates, you can visit the Moment.js website. And the DataviewJS documentation can be found here. Happy coding!",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#javascript",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#javascript",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "JavaScript is a general purpose programming language not unlike Python, but quite different from the confusingly-named Java programming language to which it bears no relation. It is responsible for most of the dynamic content on the internet. As happens with human languages spoken widely, JavaScript has evolved a variety of ‚Äúregional dialects‚Äù, sharing a common grammar and basic lexicon, but adding words and idioms to work in specific environments. DataviewJS is one such dialect, one which provides a vocabulary specifically tailored for Obsidian. It does this by giving us a Dataview object, but more on that later.\nThis will be a learn-by-example sort of thing, but it‚Äôs worth mentioning a few things up front for those totally new to this. In JavaScript, spaces, tabs and line breaks don‚Äôt matter. You could write your script on one line, but that would be silly. I suggest that you use spaces and line breaks liberally, because it will make your code much easier to write, read and quickly understand when you look back at it later. You will also see some people using semi-colons at the end of lines. This, too, is optional. Finally, variables can be named however you like, but the convention for multi-word variables is to capitalize the first letter of every word except the first, like theVariableName.\n(Fun fact: this naming convention is called ‚Äúcamel case‚Äù, with the capital letters seen as humps protruding from the back of a camel. Two humps can be seen in one form, CamelCase. The form used in JavaScript, camelCase is specifically called ‚Äúdromedary case‚Äù for apparent reasons.)\nOne thing about JavaScript which took me a while to get used to at first was all of the curly braces ({}). All that they indicate is that there is a block of JavaScript code inside, usually with multiple lines. While we‚Äôre on the subject of braces, the square brackets ([]) are used when you want a list of things. Just separate each item by commas, and put quotations around each item, like [\"Item 1\", \"Item2\"]. You often want to go through lists item by item (a process called iteration), and we will see later how to do this. Apostrophes (') and quotations (\") can be used interchangeably to wrap text. Don‚Äôt worry, we‚Äôll go over all this later.",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#hello-world",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#hello-world",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "The first program you traditionally write in any programming language is ‚ÄúHello World‚Äù, which displays, not unsurprisingly, ‚ÄúHello World‚Äù as output. Here is such a one in DataviewJS:\ndv.paragraph(\"Hello World\")\nThe output looks like this:\nHello World\nYeah! You are now a JavaScript programmer! This simple example introduces some important concepts, though.\nFirst, when you want to write some JavaScript, you must use a code block with the key word dataviewjs. While you are writing code, it can be convenient to start the code block with js dataviewjs rather than simply dataviewjs. You will get nice syntax highlighting that way, and can simply remove the first js when you want to run your code.\nAs you might have guessed, paragraph just means to display the text in parentheses as a paragraph. Technically, dv.paragraph() is a command, or function, and the part in parentheses is called the arguments. Note the quotations surrounding the text.\nSo what‚Äôs this dv thing? Remember when I said that each flavor of JavaScript provides special vocabulary for it‚Äôs context? They do this typically by providing an ‚Äúobject‚Äù containing the functionality. dv is what is called the Dataview object, and anytime you want to access the functionality of DataviewJS you indicate that by starting your statement or phrase with dv followed by a period. Since displaying a paragraph on a page of markdown is specific to DataviewJS, we write dv.paragraph()\nIn addition to paragraphs, the dv object allows us to display headers, lists, tables, etc. In fact, the dv object can display any HTML element. You can display multiple elements by putting them one after another in your code.\nLet‚Äôs look at another example:\ndv.header(2, \"Introduction to DataviewJS\")\ndv.paragraph('\"Hi, my name is DataviewJS\"')",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#introduction-to-dataviewjs",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#introduction-to-dataviewjs",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "Hi, my name is DataviewJS\nSince it‚Äôs hard to show the result naturally, I‚Äôve included screenshots from my vault with the code on the right and the results on the left.\n\nHere I‚Äôm displaying 2 elements. Headers require two arguments, the first indicating the header level. This example is the same as writing ## Introduction to DataviewJS. Note that we don‚Äôt use quotations around numbers (usually). The dv object also allows us to display lists, like this:\ndv.list([\"Item 1\", \"Item 2\", \"Item 3\"])\nRemember that, when making lists in JavaScript, you use the square brackets and separate each item with a comma. This is also called an array. This is a pretty simple example, but sometimes things get a lot more complicated, and since spaces and new lines don‚Äôt matter, it is good practice to write the same code like this:\ndv.list([\n    \"Item 1\",\n    \"Item 2\",\n    \"Item 3\",\n])\nThis makes it much easier to see what is going on, and also makes copying and pasting of individual items easier, too.",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#variables",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#variables",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "Well, you may not be too impressed so far. Nothing we‚Äôve done yet has been anything we couldn‚Äôt have done by simply writing the markdown. Things get more interesting when we start using variables. These allows us to create and manipulate information before displaying it. Variables are usually made (declared) with either const or let in JavaScript. So const myName = \"Brian\" creates a variable called myName with the value of ‚ÄúBrian‚Äù. We can then write this:\nconst myName = \"Brian\"\ndv.paragraph(\"Hi, my name is \" + myName + \".\")\nwhich produces\nHi, my name is Brian.\nWhen used with text, called strings in coding lingo, the + puts together (concatenates) multiple strings. You can see that a long string with multiple variables could start to look messy. A more convenient way to combine text and variables is to use back ticks instead of quotes, and put the variable names in curly braces preceded with the dollar sign. So instead we can write:\nconst myName = \"Brian\"\ndv.paragraph(`Hi, my name is ${myName}.`)\nto get the same result.\nYou could still object, no pun intended, that we haven‚Äôt done anything we couldn‚Äôt have done just by writing out the sentence. We‚Äôll get to that in the next article, but before closing this one, I‚Äôll show you something you can only do with JavaScript. DataviewJS comes with another JavaScript flavor baked in called MomentJS. Like DataviewJS provides a dv object, MomentJS provides a moment object which makes it easy to work with dates and times. We‚Äôll talk a lot more about this later, but for now you can use it like this:\nconst today = moment(Date.now()).format(\"MMMM DD, YYYY\")\ndv.paragraph(`Today is ${today}`)\nToday is October 10, 2023\nThis display‚Äôs today‚Äôs date in a format specified by argument to the format() function. Every time you open a note or canvas, the current day will be displayed.\nPutting it all together, we can write\nconst myName = \"Brian\"\nconst today = moment(Date.now()).format(\"MMMM DD, YYYY\")\nconst learnings = [\n    \"JavaScript basics\",\n    \"The dataview object\",\n    \"Displaying elements with JavaScript\",\n    \"JavaScript variables\",\n]\ndv.header(3, `Things ${myName} learned on ${today}`)\ndv.list(learnings)\nto produce\n\n\n\nJavaScript basics\nThe dataview object\nDisplaying elements with JavaScript\nJavaScript variables",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#next-steps",
    "href": "blogs/obsidian/gentle-introduction-to-dataviewjs/index.html#next-steps",
    "title": "DataviewJS: A Gentle Introduction",
    "section": "",
    "text": "In the next article I‚Äôll start looking at using DataviewJS to make lists and tables and otherwise use the information in your vault. Meanwhile, if you want to learn more about working with dates, you can visit the Moment.js website. And the DataviewJS documentation can be found here. Happy coding!",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "This article is a follow-up to my Gentle Introduction to DataviewJS articles, and assumes that you have read them. It is written for anglers, but if you just want the fish you can Tldr; your way to the bottom an just grab the code. Even if you are here to learn how to fish, depending on your learning style, you may want to take a look at the complete code first before this walk-through.\nWe are now ready to start building a fully dynamic and interactive dashboard to manage the exercise logs. In this case, I‚Äôm tracking the following:\n\ntype of activity\ndistance\nduration\ndate of activity\nroute\n\nI have optional fields for notes and, as you can see, for images. Summary tables are generated using calculated values. The entire canvas updates automatically to the current day.\nThis example could easily be extended for tracking anything which includes numerical data and images. Imagine a research project, for example, where observations are taken combining numerical data, textual observations, and photos. Actually creating the log entries, thanks to Metadata Menu and Unique Notes, takes almost no time. You can read about how to do this here.\nIn this article, I‚Äôll focus on creating this dynamic table.\n\nAppropriate widgets are provided allowing for direct editing or the use of popup modals for multi-select fields and dates. The list will display all logs over the last 7 days, so different logs will appear depending on the day.\nTo do this, we will use the excellent JavaScript functionality provided by Metadata Menu. It would be more interesting were you to create a bunch of logs (notes) covering a date range of at least three months and follow along. They should all contain the following fields:\n\ntopic\ntype\nRoute\nActivity\nDuration\nDistance\nNote\nImage\nLink\n\n\n\n\nThroughout this dashboard I work with time. It is natural to want to look at time periods of weeks and months, and to compare current periods to prior periods of the same length. We, just as naturally, compare a week starting Monday or Sunday to a prior week starting on the same day. And we compare February to January. This is often a good thing, because it fits the way people naturally think.\nBut if you are really looking at the numbers, you quickly see the flaw in comparing time periods this way. You can‚Äôt compare a complete week to the prior week until the end of the week. To get around this, people use week-to-date, or quite commonly month-to-date. For months the problem is worse, as in the case of Feb/Jan comparison that‚Äôs 28 days compared to 31 days. That‚Äôs more than a 10% difference in days, and therefor in data!\nA simple way around this, and one which provides better analysis, is to use rolling windows of time. Any seven day period contains every day of the week, and so comparing two of any such periods valid (and complete) week-to-week comparisons. For months, you can compare any 30 (or 28) day period to the prior period of equal length, so you get a full, month-long picture with apples-to-apples data (that‚Äôs a technical termüòâ).\nIn the first article I introduced moment(), an object provided by Dataview (by MomentJS actually). This makes time math easy. moment() itself means today, now, this very second. If you want the date/time two days ago, you can subtract two days with moment().subtract(2, \"days\"). I‚Äôll leave it as an exercise to the reader to figure out how to find the date two months ago.\nIn order to use moment() for any date other than now, you need to write, eg., moment(new Date(\"2023-10-20\"). We will do this so that we can format the date differently using the format() function in moment(). format() wants an argument, a date format string. I don‚Äôt need to see the year, and a 2-digit month is fine and shorter. On the other hand, seeing the day of the week would be useful. The format string to produce ‚Äú10/10 Tue‚Äù is ‚ÄúMM/DD ddd‚Äù. ### Challenge As an exercise, you might pause here and think about how to display ‚Äútwo days ago‚Äù in the format ‚Äú10/10 Tue‚Äù. You have all the knowledge you need. Think about chaining commands together with the period. ### Solution\nHere is a solution:\nconst dateFormat = \"MM/DD ddd\" const twoDaysAgo =\nmoment() .subtract(2, \"days\") .format(dateFormat)\n\ndv.paragraph(twoDaysAgo)\nWhen writing, and especially reading, code, formatting is important. I could have written\nconst twoDaysAgo = moment().subtract(2, \"days\").format(dateFormat)\nbut it is much less clear what is going on. If you are trying to understand a piece of code, start by reformatting. ## Asynchronous Functions\nMost computer programs execute line by line, with each line completing before moving on to the next line. Normally this is what you want. However, as the quantity of data commonly worked with increases geometrically, and the fact that it is often distributed widely across the internet, applications which require fetching data can easily grind to a halt due to a slow internet connection, slow servers, large quantities, etc. To overcome this problems, some functions are executed asynchronously. When an asynchronous function is executed, it doesn‚Äôt return the actual data. Instead, it returns what is called a promise. That allows the program to continue executing while the data is being fetched. It will continue execution until the data is actually required, at which point it will wait (not freeze).\nIn practice this is quite easy, involving the use of two new key words: async and await. The first, async, is added to the function definition, and the second, await, is added before any data fetching. That‚Äôs all you need to know so that you will understand the words when you see them.\n\n\n\nMetadata Menu provides an asynchronous function for making the tables interactive. To use the function, you must import it with\nconst {fieldModifier: f} = this.app.plugins.plugins[\"metadata-menu\"].api\nUsing the curly braces like this is called deconstructing a variable or function. This means that somewhere there is a function called fieldModifier. The : f is just an alias, so that every time you use the function you don‚Äôt need to write out fieldModifier, you can just write f.\nThe other part is interesting. Take it step by step. this is the root directory of your vault. app is the hidden obsidian directory, inside of which there is, you guessed it, a plugins directory with an entry called metadata-menu. The rest, plugins[\"metadata-menu\"].api says to look in the metadata-menu directory for something called api. This object will contain a function called fieldModifier, which we can now refer to simply as f.\nfieldModifier(), which is f() to us now, is used in map() and takes three arguments: the dv object, whatever temporary variable you are using in map() (we have been using b), and the name of the field we want. Were it a normal function you would write\ndataviewjs dv.pages()     \n  .map(b=&gt;[p.ActivityDate, \n  f(dv, b, \"Activity\"),\n  ]\nSince this fetching of date is asynchronous, you have to use the key words async/await here, so\ndataviewjs dv.pages()     \n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ]\nThe entire section containing pages().map needs to be wrapped in an asynchronous function called Promise.all(), which must be (a)waited for and returns, unsurprisingly, a promise.\nawait Promise.all(dv.pages()\n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ])\n\n\n\nNow, lets finally take a look at the entire code that creates the dashboard. Take some time to read through it. Everything should be understandable at this point.\nconst {fieldModifier: f} =\nthis.app.plugins.plugins\\[\"metadata-menu\"\\].api\n\nconst dateFormat = \"MM/DD ddd\"\n\ndv.header(3, \"7 Day Details\")\n\ndv.table(\\[\"üóìÔ∏è\",\"üö∂üö¥\", \"üìì\", \"‚è±Ô∏è\", \"üó∫Ô∏è\"\\],\n\nawait Promise.all(dv.pages()\n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\n    .sort(p =&gt; p.ActivityDate, \"desc\")\n    .map(async b=&gt;[\n        moment(new Date(b.ActivityDate)).format(dateFormat),\n        await f(dv, b, \"Activity\"), \n        await f(dv, b, \"Distance\"), \n        await f(dv, b, \"Duration\"), \n        await f(dv, b, \"Route\"),\n    ]\n  )\n)\n\n\n\nIn the next article I will explain how to generate summary information like totals and averages for display on the dashboard. In the mean time I strongly suggest that you do two things:\n\nAdd images to some of your logs and create the table for the Gallery section of the dashboard\nTurn some of your existing Dataview tables into DataviewJS tables. Or, at least, make some new ones from your own information\nSpend some time working with date ranges. In this example, we selected the past seven days. How can you select the seven days prior to that? (Hint: you need to chain together two where() clauses.)\nCan you create a month-to-date view? There are various ways to do it, but it‚Äôs helpful to know that you can do moment().startOf('month') to grab the first day of the month. Check out the documentation for more possibilities.\n\nHappy coding!",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#introduction",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#introduction",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "This article is a follow-up to my Gentle Introduction to DataviewJS articles, and assumes that you have read them. It is written for anglers, but if you just want the fish you can Tldr; your way to the bottom an just grab the code. Even if you are here to learn how to fish, depending on your learning style, you may want to take a look at the complete code first before this walk-through.\nWe are now ready to start building a fully dynamic and interactive dashboard to manage the exercise logs. In this case, I‚Äôm tracking the following:\n\ntype of activity\ndistance\nduration\ndate of activity\nroute\n\nI have optional fields for notes and, as you can see, for images. Summary tables are generated using calculated values. The entire canvas updates automatically to the current day.\nThis example could easily be extended for tracking anything which includes numerical data and images. Imagine a research project, for example, where observations are taken combining numerical data, textual observations, and photos. Actually creating the log entries, thanks to Metadata Menu and Unique Notes, takes almost no time. You can read about how to do this here.\nIn this article, I‚Äôll focus on creating this dynamic table.\n\nAppropriate widgets are provided allowing for direct editing or the use of popup modals for multi-select fields and dates. The list will display all logs over the last 7 days, so different logs will appear depending on the day.\nTo do this, we will use the excellent JavaScript functionality provided by Metadata Menu. It would be more interesting were you to create a bunch of logs (notes) covering a date range of at least three months and follow along. They should all contain the following fields:\n\ntopic\ntype\nRoute\nActivity\nDuration\nDistance\nNote\nImage\nLink",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#time-math",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#time-math",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "Throughout this dashboard I work with time. It is natural to want to look at time periods of weeks and months, and to compare current periods to prior periods of the same length. We, just as naturally, compare a week starting Monday or Sunday to a prior week starting on the same day. And we compare February to January. This is often a good thing, because it fits the way people naturally think.\nBut if you are really looking at the numbers, you quickly see the flaw in comparing time periods this way. You can‚Äôt compare a complete week to the prior week until the end of the week. To get around this, people use week-to-date, or quite commonly month-to-date. For months the problem is worse, as in the case of Feb/Jan comparison that‚Äôs 28 days compared to 31 days. That‚Äôs more than a 10% difference in days, and therefor in data!\nA simple way around this, and one which provides better analysis, is to use rolling windows of time. Any seven day period contains every day of the week, and so comparing two of any such periods valid (and complete) week-to-week comparisons. For months, you can compare any 30 (or 28) day period to the prior period of equal length, so you get a full, month-long picture with apples-to-apples data (that‚Äôs a technical termüòâ).\nIn the first article I introduced moment(), an object provided by Dataview (by MomentJS actually). This makes time math easy. moment() itself means today, now, this very second. If you want the date/time two days ago, you can subtract two days with moment().subtract(2, \"days\"). I‚Äôll leave it as an exercise to the reader to figure out how to find the date two months ago.\nIn order to use moment() for any date other than now, you need to write, eg., moment(new Date(\"2023-10-20\"). We will do this so that we can format the date differently using the format() function in moment(). format() wants an argument, a date format string. I don‚Äôt need to see the year, and a 2-digit month is fine and shorter. On the other hand, seeing the day of the week would be useful. The format string to produce ‚Äú10/10 Tue‚Äù is ‚ÄúMM/DD ddd‚Äù. ### Challenge As an exercise, you might pause here and think about how to display ‚Äútwo days ago‚Äù in the format ‚Äú10/10 Tue‚Äù. You have all the knowledge you need. Think about chaining commands together with the period. ### Solution\nHere is a solution:\nconst dateFormat = \"MM/DD ddd\" const twoDaysAgo =\nmoment() .subtract(2, \"days\") .format(dateFormat)\n\ndv.paragraph(twoDaysAgo)\nWhen writing, and especially reading, code, formatting is important. I could have written\nconst twoDaysAgo = moment().subtract(2, \"days\").format(dateFormat)\nbut it is much less clear what is going on. If you are trying to understand a piece of code, start by reformatting. ## Asynchronous Functions\nMost computer programs execute line by line, with each line completing before moving on to the next line. Normally this is what you want. However, as the quantity of data commonly worked with increases geometrically, and the fact that it is often distributed widely across the internet, applications which require fetching data can easily grind to a halt due to a slow internet connection, slow servers, large quantities, etc. To overcome this problems, some functions are executed asynchronously. When an asynchronous function is executed, it doesn‚Äôt return the actual data. Instead, it returns what is called a promise. That allows the program to continue executing while the data is being fetched. It will continue execution until the data is actually required, at which point it will wait (not freeze).\nIn practice this is quite easy, involving the use of two new key words: async and await. The first, async, is added to the function definition, and the second, await, is added before any data fetching. That‚Äôs all you need to know so that you will understand the words when you see them.",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#metadata-menu",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#metadata-menu",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "Metadata Menu provides an asynchronous function for making the tables interactive. To use the function, you must import it with\nconst {fieldModifier: f} = this.app.plugins.plugins[\"metadata-menu\"].api\nUsing the curly braces like this is called deconstructing a variable or function. This means that somewhere there is a function called fieldModifier. The : f is just an alias, so that every time you use the function you don‚Äôt need to write out fieldModifier, you can just write f.\nThe other part is interesting. Take it step by step. this is the root directory of your vault. app is the hidden obsidian directory, inside of which there is, you guessed it, a plugins directory with an entry called metadata-menu. The rest, plugins[\"metadata-menu\"].api says to look in the metadata-menu directory for something called api. This object will contain a function called fieldModifier, which we can now refer to simply as f.\nfieldModifier(), which is f() to us now, is used in map() and takes three arguments: the dv object, whatever temporary variable you are using in map() (we have been using b), and the name of the field we want. Were it a normal function you would write\ndataviewjs dv.pages()     \n  .map(b=&gt;[p.ActivityDate, \n  f(dv, b, \"Activity\"),\n  ]\nSince this fetching of date is asynchronous, you have to use the key words async/await here, so\ndataviewjs dv.pages()     \n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ]\nThe entire section containing pages().map needs to be wrapped in an asynchronous function called Promise.all(), which must be (a)waited for and returns, unsurprisingly, a promise.\nawait Promise.all(dv.pages()\n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ])",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#the-table",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#the-table",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "Now, lets finally take a look at the entire code that creates the dashboard. Take some time to read through it. Everything should be understandable at this point.\nconst {fieldModifier: f} =\nthis.app.plugins.plugins\\[\"metadata-menu\"\\].api\n\nconst dateFormat = \"MM/DD ddd\"\n\ndv.header(3, \"7 Day Details\")\n\ndv.table(\\[\"üóìÔ∏è\",\"üö∂üö¥\", \"üìì\", \"‚è±Ô∏è\", \"üó∫Ô∏è\"\\],\n\nawait Promise.all(dv.pages()\n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\n    .sort(p =&gt; p.ActivityDate, \"desc\")\n    .map(async b=&gt;[\n        moment(new Date(b.ActivityDate)).format(dateFormat),\n        await f(dv, b, \"Activity\"), \n        await f(dv, b, \"Distance\"), \n        await f(dv, b, \"Duration\"), \n        await f(dv, b, \"Route\"),\n    ]\n  )\n)",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#next-steps",
    "href": "blogs/obsidian/dataviewjs-summaries-statistics/index.html#next-steps",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "In the next article I will explain how to generate summary information like totals and averages for display on the dashboard. In the mean time I strongly suggest that you do two things:\n\nAdd images to some of your logs and create the table for the Gallery section of the dashboard\nTurn some of your existing Dataview tables into DataviewJS tables. Or, at least, make some new ones from your own information\nSpend some time working with date ranges. In this example, we selected the past seven days. How can you select the seven days prior to that? (Hint: you need to chain together two where() clauses.)\nCan you create a month-to-date view? There are various ways to do it, but it‚Äôs helpful to know that you can do moment().startOf('month') to grab the first day of the month. Check out the documentation for more possibilities.\n\nHappy coding!",
    "crumbs": [
      "Obsidian",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/data-science/gpx-gps-data/index.html",
    "href": "blogs/data-science/gpx-gps-data/index.html",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I‚Äôm most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a ‚Äúyou are here‚Äù, if you will, or maybe ‚ÄúThere, but for the grace of God‚Ä¶‚Äù.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my ‚Äúfriends‚Äù like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I‚Äôd happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I‚Äôm doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into ‚Äútrajectories‚Äù, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Data Science",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "blogs/data-science/gpx-gps-data/index.html#introduction",
    "href": "blogs/data-science/gpx-gps-data/index.html#introduction",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I‚Äôm most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a ‚Äúyou are here‚Äù, if you will, or maybe ‚ÄúThere, but for the grace of God‚Ä¶‚Äù.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my ‚Äúfriends‚Äù like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I‚Äôd happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I‚Äôm doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into ‚Äútrajectories‚Äù, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Data Science",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "This article follows an earlier article introducing DataviewJS, which I strongly encourage you to read first. In that article, we learned how to display basic lists with Dataview. In this article, I will cover displaying lists of files in your vault and information in those files. I will also discuss using date ranges in queries and sorting results. Finally I will show how to make a table with multiple fields.\nAs a refresher, to show a list with a header you typed something like\nconst myList = [\n    \"First\",\n    \"Second\",\n    \"Third\"\n]\n\ndv.header(3, \"My List\")\ndv.list(myList)\n.\nThis creates a variable with a camelCase name. The variable contains a list, surrounded by square brackets, separated by commas, with quotations around strings (text). That was easy.\nNow what if I want to list all the files in my vault? I won‚Äôt do this, because the list would be crazy long, but just say I did. I would use\nconst fileNameList = dv.pages().file.name\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nThis would give me a bullet-point list of the names of all of the files in my vault. If you don‚Äôt have too many files in your vault, go ahead and try. Before narrowing it down to something more specific, let‚Äôs look at what is new here. What is pages().file.name? And for that matter, what‚Äôs with all the periods?\nLet me explain the periods first. I said that dv is an object. Objects can contain functions, like list(). They can also contain values, often called attributes. The functions and attributes of any object are referred to or accessed by using the name of the object, followed by a period, and then the name of the function or attribute. So the phrase above means: dv is an object that contains a pages() function (the parentheses let you know it is a function). The pages() function selects certain pages and provides attributes for each page, such as the name, links, date created, date modified, etc., in an object called file. In this case I‚Äôm choosing to show just the file name. If I wanted links instead, I would do dv.pages().file.link.\nThis dot-notation, using periods, is actually quite nice when you get used to it. Recall that ‚Äúwhite space‚Äù, including line breaks, is not important in JavaScript, so you will see me often using line breaks before these periods, purely for readability and ease of editing.\nSo let‚Äôs see how to narrow things down a little. For the following examples I will use my exercise logs. All the log files are linked to a file called Logs. I can select files that link to this Logs file by writing pages(\"[[Logs]]\"). Note the quotations AND double square brackets. So I can write:\nconst fileNameList = dv.pages(\"[[Logs]]\").file.link\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nI suggest you create some log files in your vault so that you can follow along. Each file should contain, at least, the following fields, some of which we won‚Äôt use until we look at tables:\ntopic:: [[Logs]]\ntype:: log\nActivity:: üö∂\nDuration:: 60\nDistance:: 3\nActivityDate:: 2023-10-05\nI use üö¥ as the other activity type. After creating some log files, and the Logs file itself (this file can be empty for now), go ahead and try the JavaScript. You can use this technique to retrieve files on any topic in this way, assuming you have a topic field with the link (really you only need there to be a link).\n\n\n\nLet‚Äôs look at some ways we can modify this snippet to make it more useful. First, if you have tried this, and have created log files with various dates, you may notice that they aren‚Äôt necessarily displayed in any particular order. I want to make sure they are ordered by the activity date. The pages() object contains a number of functions allowing us to work with data, and sort() is one. sort() takes two arguments, first the name of the field to sort on, and a second argument specifying the sort order, either \"asc\" or \"desc\", for ascending or descending order, respectively.\nUnfortunately, we can‚Äôt just add .sort(ActivityDate, \"desc\"). When working with pages() we need to use a special JavaScript syntax. We need to type .sort(a =&gt; a.ActivityDate, \"desc\"). The letter a is arbitrary. I could also write .sort(foo =&gt; foo.ActivityDate, \"desc\") to achieve the same thing. a, or foo, basically serves as temporary variable name for the object you are working with, in this case the page, or note. Then the command says to use the ActivityDate property on each page for sorting. I know it looks a little confusing at first, but you will see this idiom so frequently you will quickly get used to it.\nSo lets sort our logs by date as so:\nconst fileNameList = dv.pages(\"[[Logs]]\")                                                                                                                \n    .sort(b =&gt; b.ActivityDate, \"desc\")                                                                                                                   \n    .ActivityDate\n\ndv.header(3, \"Activity Dates\")\ndv.list(fileNameList)\nNotice how the dot notation allows us to easily add more conditions to our query. ## Selecting by date\nNext, let‚Äôs see how we can select logs only for certain dates. To do that, we use the .where() function supplied by pages(). To see only logs since October 3, 2023, I can write\nconst fileNameList = dv.pages(\"[[Logs]]\")\n  .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .ActivityDate                \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nThe syntax for where() is similar to the syntax for sort(). There is an important difference though, because here we are comparing two values. &gt;= means ‚Äúgreater than or equal to‚Äù, &lt;= would be ‚Äúless than or equal to‚Äù, etc. This evaluates to either true or false, since the date is either earlier or later than 10/3. This type of true/false value has a special name, boolean, which is good to know. dv provides its own .date() function for simple date manipulation, and I use it here.\nNow that you know how to use where(), let‚Äôs do one more thing with it. The code currently takes advantage of the fact that all the logs are linked to the Logs note. I don‚Äôt like that, because I might create some logs with a different topic. You may have noticed that all of the log notes have a type:: log. This can be used with .where(), so I can instead write:\nconst fileNameList = dv.pages()\n .where(b =&gt; b.type == \"log\")\n .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n .sort(b =&gt; b.ActivityDate, \"desc\")\n .ActivityDate\n                                                             \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nMany of my queries are based on the type of note, and this is how the note type can be used. Pay attention to the fact that ‚Äúequal to‚Äù requires two equal signs, not one. For completeness, ‚Äúnot equal to‚Äù is written !=.\n\n\n\nLists aren‚Äôt very interesting, though. Usually you want more than just the name, or one bit of information from a file. So let‚Äôs make a table instead with dv.table(). For tables, you must supply an additional list with the column headers. Then you specify the fields that you want using a JavaScript function called map(). It works pretty much the same way as .sort and .where(), it just has a seemingly odd name. map() is used to go through each item in a list and do something with it, in this case, select certain fields from each note. This is called iteration.\nThis table shows the type of activity, distance in miles, duration in minutes and date. I‚Äôve used emojis for column headings. You can see that the fields I want shown are supplied as a list (between square brackets) of the fields I want in the table.\n\nconst headers = [\"üö∂/üö¥\", \"üóíÔ∏è\", \"‚è±Ô∏è\", \"üìÖ\"]\n\nconst pages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .map(b =&gt; [\n        b.Activity, \n        b.Distance, \n        b.Duration, \n        b.ActivityDate\n    ])\n                                \n\ndv.header(3, \"Activity since October 3, 2023\")\ndv.table(headers,   pages)\n\n\n\n\nIn the next article I will look at how to make this table dynamic, allowing you to change values directly in the table. I will also talk about relative dates, eg. activity over the last 10 days, or in the 10 days prior to that, or before a certain day but after another day.\nBefore moving on, I strongly encourage you to work with the material covered so far by adding some metadata to your existing notes and creating some queries. I don‚Äôt use tags (for now), but if you do, you could do pages(\"#some/tag\") instead of pages(\"[[Logs]]\"). Maybe you have a tag, #fleeting, for example. You could make a list of all your fleeting notes with pages(#fleeting).\nFinally, if you have been reading my Freeing Your Thinking series you may already be doing these examples on a canvas instead of in a note. If you aren‚Äôt I encourage you to do so. You can put the code directly into cards on a canvas. Then you can easily see all of your tables in one place, and convert them into notes if you so desire (but why?). Since the end goal will be to have dashboards to view and manage things, you might as well start now. If you have multiple tables on the same canvas, you might want to increase the Refresh Rate in the Dataview settings to prevent the canvas from being too ‚Äújumpy‚Äù while you type. The default is 2500ms (2.5 seconds). I find that 5 seconds (5000ms) works pretty well for me and the speed I type.\nHappy coding!",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html#selecting-files",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html#selecting-files",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "This article follows an earlier article introducing DataviewJS, which I strongly encourage you to read first. In that article, we learned how to display basic lists with Dataview. In this article, I will cover displaying lists of files in your vault and information in those files. I will also discuss using date ranges in queries and sorting results. Finally I will show how to make a table with multiple fields.\nAs a refresher, to show a list with a header you typed something like\nconst myList = [\n    \"First\",\n    \"Second\",\n    \"Third\"\n]\n\ndv.header(3, \"My List\")\ndv.list(myList)\n.\nThis creates a variable with a camelCase name. The variable contains a list, surrounded by square brackets, separated by commas, with quotations around strings (text). That was easy.\nNow what if I want to list all the files in my vault? I won‚Äôt do this, because the list would be crazy long, but just say I did. I would use\nconst fileNameList = dv.pages().file.name\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nThis would give me a bullet-point list of the names of all of the files in my vault. If you don‚Äôt have too many files in your vault, go ahead and try. Before narrowing it down to something more specific, let‚Äôs look at what is new here. What is pages().file.name? And for that matter, what‚Äôs with all the periods?\nLet me explain the periods first. I said that dv is an object. Objects can contain functions, like list(). They can also contain values, often called attributes. The functions and attributes of any object are referred to or accessed by using the name of the object, followed by a period, and then the name of the function or attribute. So the phrase above means: dv is an object that contains a pages() function (the parentheses let you know it is a function). The pages() function selects certain pages and provides attributes for each page, such as the name, links, date created, date modified, etc., in an object called file. In this case I‚Äôm choosing to show just the file name. If I wanted links instead, I would do dv.pages().file.link.\nThis dot-notation, using periods, is actually quite nice when you get used to it. Recall that ‚Äúwhite space‚Äù, including line breaks, is not important in JavaScript, so you will see me often using line breaks before these periods, purely for readability and ease of editing.\nSo let‚Äôs see how to narrow things down a little. For the following examples I will use my exercise logs. All the log files are linked to a file called Logs. I can select files that link to this Logs file by writing pages(\"[[Logs]]\"). Note the quotations AND double square brackets. So I can write:\nconst fileNameList = dv.pages(\"[[Logs]]\").file.link\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nI suggest you create some log files in your vault so that you can follow along. Each file should contain, at least, the following fields, some of which we won‚Äôt use until we look at tables:\ntopic:: [[Logs]]\ntype:: log\nActivity:: üö∂\nDuration:: 60\nDistance:: 3\nActivityDate:: 2023-10-05\nI use üö¥ as the other activity type. After creating some log files, and the Logs file itself (this file can be empty for now), go ahead and try the JavaScript. You can use this technique to retrieve files on any topic in this way, assuming you have a topic field with the link (really you only need there to be a link).",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html#sorting",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html#sorting",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "Let‚Äôs look at some ways we can modify this snippet to make it more useful. First, if you have tried this, and have created log files with various dates, you may notice that they aren‚Äôt necessarily displayed in any particular order. I want to make sure they are ordered by the activity date. The pages() object contains a number of functions allowing us to work with data, and sort() is one. sort() takes two arguments, first the name of the field to sort on, and a second argument specifying the sort order, either \"asc\" or \"desc\", for ascending or descending order, respectively.\nUnfortunately, we can‚Äôt just add .sort(ActivityDate, \"desc\"). When working with pages() we need to use a special JavaScript syntax. We need to type .sort(a =&gt; a.ActivityDate, \"desc\"). The letter a is arbitrary. I could also write .sort(foo =&gt; foo.ActivityDate, \"desc\") to achieve the same thing. a, or foo, basically serves as temporary variable name for the object you are working with, in this case the page, or note. Then the command says to use the ActivityDate property on each page for sorting. I know it looks a little confusing at first, but you will see this idiom so frequently you will quickly get used to it.\nSo lets sort our logs by date as so:\nconst fileNameList = dv.pages(\"[[Logs]]\")                                                                                                                \n    .sort(b =&gt; b.ActivityDate, \"desc\")                                                                                                                   \n    .ActivityDate\n\ndv.header(3, \"Activity Dates\")\ndv.list(fileNameList)\nNotice how the dot notation allows us to easily add more conditions to our query. ## Selecting by date\nNext, let‚Äôs see how we can select logs only for certain dates. To do that, we use the .where() function supplied by pages(). To see only logs since October 3, 2023, I can write\nconst fileNameList = dv.pages(\"[[Logs]]\")\n  .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .ActivityDate                \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nThe syntax for where() is similar to the syntax for sort(). There is an important difference though, because here we are comparing two values. &gt;= means ‚Äúgreater than or equal to‚Äù, &lt;= would be ‚Äúless than or equal to‚Äù, etc. This evaluates to either true or false, since the date is either earlier or later than 10/3. This type of true/false value has a special name, boolean, which is good to know. dv provides its own .date() function for simple date manipulation, and I use it here.\nNow that you know how to use where(), let‚Äôs do one more thing with it. The code currently takes advantage of the fact that all the logs are linked to the Logs note. I don‚Äôt like that, because I might create some logs with a different topic. You may have noticed that all of the log notes have a type:: log. This can be used with .where(), so I can instead write:\nconst fileNameList = dv.pages()\n .where(b =&gt; b.type == \"log\")\n .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n .sort(b =&gt; b.ActivityDate, \"desc\")\n .ActivityDate\n                                                             \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nMany of my queries are based on the type of note, and this is how the note type can be used. Pay attention to the fact that ‚Äúequal to‚Äù requires two equal signs, not one. For completeness, ‚Äúnot equal to‚Äù is written !=.",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html#a-first-table",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html#a-first-table",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "Lists aren‚Äôt very interesting, though. Usually you want more than just the name, or one bit of information from a file. So let‚Äôs make a table instead with dv.table(). For tables, you must supply an additional list with the column headers. Then you specify the fields that you want using a JavaScript function called map(). It works pretty much the same way as .sort and .where(), it just has a seemingly odd name. map() is used to go through each item in a list and do something with it, in this case, select certain fields from each note. This is called iteration.\nThis table shows the type of activity, distance in miles, duration in minutes and date. I‚Äôve used emojis for column headings. You can see that the fields I want shown are supplied as a list (between square brackets) of the fields I want in the table.\n\nconst headers = [\"üö∂/üö¥\", \"üóíÔ∏è\", \"‚è±Ô∏è\", \"üìÖ\"]\n\nconst pages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .map(b =&gt; [\n        b.Activity, \n        b.Distance, \n        b.Duration, \n        b.ActivityDate\n    ])\n                                \n\ndv.header(3, \"Activity since October 3, 2023\")\ndv.table(headers,   pages)",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-files-dates/index.html#next-steps",
    "href": "blogs/obsidian/dataviewjs-files-dates/index.html#next-steps",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "In the next article I will look at how to make this table dynamic, allowing you to change values directly in the table. I will also talk about relative dates, eg. activity over the last 10 days, or in the 10 days prior to that, or before a certain day but after another day.\nBefore moving on, I strongly encourage you to work with the material covered so far by adding some metadata to your existing notes and creating some queries. I don‚Äôt use tags (for now), but if you do, you could do pages(\"#some/tag\") instead of pages(\"[[Logs]]\"). Maybe you have a tag, #fleeting, for example. You could make a list of all your fleeting notes with pages(#fleeting).\nFinally, if you have been reading my Freeing Your Thinking series you may already be doing these examples on a canvas instead of in a note. If you aren‚Äôt I encourage you to do so. You can put the code directly into cards on a canvas. Then you can easily see all of your tables in one place, and convert them into notes if you so desire (but why?). Since the end goal will be to have dashboards to view and manage things, you might as well start now. If you have multiple tables on the same canvas, you might want to increase the Refresh Rate in the Dataview settings to prevent the canvas from being too ‚Äújumpy‚Äù while you type. The default is 2500ms (2.5 seconds). I find that 5 seconds (5000ms) works pretty well for me and the speed I type.\nHappy coding!",
    "crumbs": [
      "Obsidian",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "This article follows up on earlier articles in which I showed how to create interactive tables which are automatically updated and can be edited directly in the table. This article will describe how to create summary statistics for data. The statistics on the dashboard update based on the current day.\nAs you can see, I‚Äôve done a bit of rearranging since the last article to make things even more readable. The statistics tables have been re-sized and reformatted for a cleaner display, and I‚Äôve added more information. There are still some tweaks I want to do, but this is a very useful dashboard.\nA quick comment on canvases: since I started working on canvases it‚Äôs hard to go back to the 80 characters wide format of a note. Sure, when I‚Äôm writing an article or focusing on a bit of code, that format feels very natural. But when doing pretty much anything else, well, it‚Äôs just nice to be able to spread out, and not have to open and close files, or page up and down through documents. Using a canvas is like putting all of your current work on your desk, with everything open to the pages you are interested in. In a future article I will show how a dashboard can be used in place of a Daily Note to manage your day.\nHere is the table I will show how to create in this article. As before, you can just skip to the bottom and grab the code if you want. This article explains everything rather thoroughly and introduces some general programming concepts. I think that, if you spend a little time with the material you will find that it is not, as they say, rocket science.\n\nThat‚Äôs 22 numbers to calculate! The process isn‚Äôt too complicated, but we need to keep track of a lot of things. To avoid a lot of repetition, we will create some custom functions, and you need to learn how to ‚Äúpush‚Äù lists into lists.\nLet‚Äôs start by writing down what we need to do.\n\nCreate the data sets\n\nGet the logs for current and prior periods\nSeparate by activity\n\nMake a variable and calculate each statistic for current and prior periods\n\ndistance for each activity and total (6 total)\nduration for each activity and total (6 total)\nspeed for each activity (4 total)\ncounts for each activity (6 total)\n\nGenerate the output\n\nCreate the tables‚Äô headers\nGenerate the table rows\nCreate headers for the with workout totals\nDisplay the tables with header elements\n\n\n\n\nFirst, let‚Äôs grab the data for the current and prior seven day periods. In the last article I showed how to get the current period. Did you figure out how to get the prior period? One way is to first take the data from the last 14 days, and then remove the most recent 7 days. So we‚Äôll do it like this:\nconst priorPages = dv.pages() \n                    .where(b =&gt; b.type == \"log\")\n                    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n                    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \n\nCreate the currentPages data set as well. Then each needs to be separated by walking and biking. You can do it like this:\nconst currentWalkPages = currentPages\n                    .where(b =&gt; b.Activity == \"üö∂\")\nGo ahead and create the rest of the datasets. You need currentBikePages, priorWalkPages and priorBikePages.\n\n\n\nGood programming involves avoiding repetitive tasks. Whenever you need to do the same thing more than once or twice, the standard practice is to make a function.\n\n\nHere is an example of a function we can use. It is arguably overkill to make this a function, but it will provide a good example. A function starts with the keyword function followed by the name you want to use. The name is followed by parentheses which are required, but may be empty. They are used to pass arguments to the function. The function itself is then placed in curly braces. After the function does it‚Äôs work, it needs to return some value.\nI have a bunch of numbers in minutes which I want to convert to hours. This is just a matter of dividing by 60 of course, but I also want to round off to one decimal. There is a function toFixed() which can be used on strings. It takes one argument, the number of decimal places you want to round it to. This is the function:\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\nand I use it like this.\nconst totalCurrentTime = toHours( sumStat(\"duration\", pages) )\nOf course, I haven‚Äôt created sumStat() yet. To calculate the sum there is a JavaScript function called reduce(). It is used like this:\nreduce(\n    (sum, b) =&gt; sum + b.Distance,\n     0\n)\nThe syntax looks a little complicated, but it‚Äôs not so bad if you break it down. reduce() takes two arguments. The first argument is (sum, b) =&gt; sum + b.Distance, which is itself a function with two arguments. The second argument here is our old friend b. In this case, we also need temporary variable called an accumulator. The name of this variable is arbitrary, like b. reduce() will go through each log, adding the value of the Distance field to the accumulator. The second argument to reduce() is just the initial value for the accumulator, which is almost always 0.\nNow I can write the function like this\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    \n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\nI didn‚Äôt want to write two separate functions for calculating the sums, instead I use a conditional if statement, which works as you might expect. Notice a few things about this. First, pageValues just saves us adding .values to each if statement. if statements require a condition in parentheses. It must be something that evaluates to a boolean value (true or false, remember). Then, as usual, the block of code you want to execute must be in curly braces. Finally, you almost always want to return something. Once you hit a return statement, nothing else gets executed in the function.\n\n\n\nNow we can create all of our time and distance variables like this:\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\nSpeed is just distance over time, so.\nconst currentWalkSpeed = (\n    totalCurrentWalkDistance / totalCurrentWalkTime\n    )\n    .toFixed(1)\nNotice that I specified to round to one decimal point. To find the total number of workouts it is necessary merely to count the number of pages in each category, since each represents one workout. pages() is a list, or array. Arrays all have an attribute/property called length. So to count all workouts in the last seven days I can just write const currentCount = currentPages.length.\nEverything else is just repetition, since we need 22 values at the end of the day. Any repetitive activity cries out for a new function to encapsulate this repetition, but I‚Äôll leave that for another day. (This is called refactoring.)\n\n\n\n\nThe tables from the last article used a dv.pages() object for the table rows. This time I need to create each table row myself. Each table row is itself a list. So I need a list of lists. It is easy to do this with the push() command, which just adds an item to a list. The item being added can be anything, including a list. I will build the table rows like this:\nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nI have to initialize the variable, because I can‚Äôt push anything onto a non-existent list. I used let instead of const. The difference is that a const variable cannot change after it has been created, while one declared with var can. (In older code you will see var instead of let. This still works but let is preferred.)\nSo all that remains is to push each row of the table into the rows variable, create the headers for the table, and use dv.table() to display it. The final code is at the bottom. I strongly suggest, having reached this point, that you try to do this on your own and don‚Äôt simply copy and paste my code.\n\n\n\nIf you read through both articles, congratulations. Give yourself a pat on the back. You are doing object-oriented programming in the most widely-used language on the internet. And you have all of the knowledge you need to create rich, useful dashboards.\nHappy coding!\n/* Create data sets  */\n\nconst currentPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\nconst priorPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \nconst currentWalkPages = currentPages\n    .where(b =&gt; b.Activity == \"üö∂\")\nconst currentBikePages = currentPages\n    .where(b =&gt; b.Activity == \"üö¥\")\nconst priorWalkPages = priorPages\n    .where(b =&gt; b.Activity == \"üö∂\")\nconst priorBikePages = priorPages\n    .where(b =&gt; b.Activity == \"üö¥\")\n\n/* Function to sum the distances, duration */\n\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    \n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\n\n/* Function to convert minutes to hours */\n\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\n\n\n/* Calculate the distances (6 values) */\n\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\n\nconst totalCurrentWalkDistance = sumStat(\"distance\",currentWalkPages).toFixed(1)\nconst totalCurrentBikeDistance = sumStat(\"distance\", currentBikePages).toFixed(1)\nconst totalPriorDistance = sumStat(\"distance\",priorPages).toFixed(1)\nconst totalPriorWalkDistance = sumStat(\"distance\",priorWalkPages).toFixed(1)\nconst totalPriorBikeDistance = sumStat(\"distance\",priorBikePages).toFixed(1)\n\n/* Calculate the durations (6 values) */\n\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\n\nconst totalCurrentWalkTime = toHours(sumStat(\"duration\",currentWalkPages))\nconst totalCurrentBikeTime = toHours(sumStat(\"duration\",currentBikePages))\nconst totalPriorTime = toHours(sumStat(\"duration\",priorPages))\nconst totalPriorWalkTime = toHours(sumStat(\"duration\",priorWalkPages))\nconst totalPriorBikeTime = toHours(sumStat(\"duration\",priorBikePages))\n\n/* Calculate the speed (4 values) */\n\nconst currentWalkSpeed = (totalCurrentWalkDistance / totalCurrentWalkTime).toFixed(1)\nconst priorWalkSpeed = (totalPriorWalkDistance / totalPriorWalkTime).toFixed(1)\nconst currentBikeSpeed = (totalCurrentBikeDistance / totalCurrentBikeTime).toFixed(1)\nconst priorBikeSpeed = (totalPriorBikeDistance / totalPriorBikeTime).toFixed(1)\n\n/* Count the workouts */\n\nconst currentCount = currentPages.length\nconst priorCount = priorPages.length\nconst currentBikeCount = currentBikePages.length\nconst priorBikeCount = priorBikePages.length\nconst currentWalkCount = currentWalkPages.length\nconst priorWalkCount = priorWalkPages.length\n\n\n\n/* Create an array (list) and add the table rows\n   The first table displays the distance and duration */\n   \nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nrows.push([\"üö∂\", totalCurrentWalkDistance, totalPriorWalkDistance])\nrows.push([\"üö¥\", totalCurrentBikeDistance, totalPriorBikeDistance])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Hours\", totalCurrentTime, totalPriorTime])\nrows.push([\"üö∂\", totalCurrentWalkTime, totalPriorWalkTime])\nrows.push([\"üö¥\", totalCurrentBikeTime, totalPriorBikeTime])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Speed (m/h)\", \"\", \"\"])\nrows.push([\"üö∂\", currentWalkSpeed, priorWalkSpeed])\nrows.push([\"üö¥\", currentBikeSpeed, priorBikeSpeed])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Workouts\", currentCount, priorCount])\nrows.push([\"üö∂\", currentWalkCount, priorWalkCount])\nrows.push([\"üö¥\", currentBikeCount, priorBikeCount])\n\n/* Create the table header */\n\nconst tableHeader = [\"\",\"Current\",\"Prior\"]\n\n/* Display the table */\n\ndv.header(3, \"7 Day Stats\")\ndv.table(tableHeader, rows)",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#the-data",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#the-data",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "First, let‚Äôs grab the data for the current and prior seven day periods. In the last article I showed how to get the current period. Did you figure out how to get the prior period? One way is to first take the data from the last 14 days, and then remove the most recent 7 days. So we‚Äôll do it like this:\nconst priorPages = dv.pages() \n                    .where(b =&gt; b.type == \"log\")\n                    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n                    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \n\nCreate the currentPages data set as well. Then each needs to be separated by walking and biking. You can do it like this:\nconst currentWalkPages = currentPages\n                    .where(b =&gt; b.Activity == \"üö∂\")\nGo ahead and create the rest of the datasets. You need currentBikePages, priorWalkPages and priorBikePages.",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#calculations",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#calculations",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "Good programming involves avoiding repetitive tasks. Whenever you need to do the same thing more than once or twice, the standard practice is to make a function.\n\n\nHere is an example of a function we can use. It is arguably overkill to make this a function, but it will provide a good example. A function starts with the keyword function followed by the name you want to use. The name is followed by parentheses which are required, but may be empty. They are used to pass arguments to the function. The function itself is then placed in curly braces. After the function does it‚Äôs work, it needs to return some value.\nI have a bunch of numbers in minutes which I want to convert to hours. This is just a matter of dividing by 60 of course, but I also want to round off to one decimal. There is a function toFixed() which can be used on strings. It takes one argument, the number of decimal places you want to round it to. This is the function:\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\nand I use it like this.\nconst totalCurrentTime = toHours( sumStat(\"duration\", pages) )\nOf course, I haven‚Äôt created sumStat() yet. To calculate the sum there is a JavaScript function called reduce(). It is used like this:\nreduce(\n    (sum, b) =&gt; sum + b.Distance,\n     0\n)\nThe syntax looks a little complicated, but it‚Äôs not so bad if you break it down. reduce() takes two arguments. The first argument is (sum, b) =&gt; sum + b.Distance, which is itself a function with two arguments. The second argument here is our old friend b. In this case, we also need temporary variable called an accumulator. The name of this variable is arbitrary, like b. reduce() will go through each log, adding the value of the Distance field to the accumulator. The second argument to reduce() is just the initial value for the accumulator, which is almost always 0.\nNow I can write the function like this\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    \n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\nI didn‚Äôt want to write two separate functions for calculating the sums, instead I use a conditional if statement, which works as you might expect. Notice a few things about this. First, pageValues just saves us adding .values to each if statement. if statements require a condition in parentheses. It must be something that evaluates to a boolean value (true or false, remember). Then, as usual, the block of code you want to execute must be in curly braces. Finally, you almost always want to return something. Once you hit a return statement, nothing else gets executed in the function.\n\n\n\nNow we can create all of our time and distance variables like this:\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\nSpeed is just distance over time, so.\nconst currentWalkSpeed = (\n    totalCurrentWalkDistance / totalCurrentWalkTime\n    )\n    .toFixed(1)\nNotice that I specified to round to one decimal point. To find the total number of workouts it is necessary merely to count the number of pages in each category, since each represents one workout. pages() is a list, or array. Arrays all have an attribute/property called length. So to count all workouts in the last seven days I can just write const currentCount = currentPages.length.\nEverything else is just repetition, since we need 22 values at the end of the day. Any repetitive activity cries out for a new function to encapsulate this repetition, but I‚Äôll leave that for another day. (This is called refactoring.)",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#generate-the-output",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#generate-the-output",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "The tables from the last article used a dv.pages() object for the table rows. This time I need to create each table row myself. Each table row is itself a list. So I need a list of lists. It is easy to do this with the push() command, which just adds an item to a list. The item being added can be anything, including a list. I will build the table rows like this:\nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nI have to initialize the variable, because I can‚Äôt push anything onto a non-existent list. I used let instead of const. The difference is that a const variable cannot change after it has been created, while one declared with var can. (In older code you will see var instead of let. This still works but let is preferred.)\nSo all that remains is to push each row of the table into the rows variable, create the headers for the table, and use dv.table() to display it. The final code is at the bottom. I strongly suggest, having reached this point, that you try to do this on your own and don‚Äôt simply copy and paste my code.",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#final-thoughts",
    "href": "blogs/obsidian/dataviewjs-interactive-dynamic-tables/index.html#final-thoughts",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "If you read through both articles, congratulations. Give yourself a pat on the back. You are doing object-oriented programming in the most widely-used language on the internet. And you have all of the knowledge you need to create rich, useful dashboards.\nHappy coding!\n/* Create data sets  */\n\nconst currentPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\nconst priorPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \nconst currentWalkPages = currentPages\n    .where(b =&gt; b.Activity == \"üö∂\")\nconst currentBikePages = currentPages\n    .where(b =&gt; b.Activity == \"üö¥\")\nconst priorWalkPages = priorPages\n    .where(b =&gt; b.Activity == \"üö∂\")\nconst priorBikePages = priorPages\n    .where(b =&gt; b.Activity == \"üö¥\")\n\n/* Function to sum the distances, duration */\n\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    \n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\n\n/* Function to convert minutes to hours */\n\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\n\n\n/* Calculate the distances (6 values) */\n\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\n\nconst totalCurrentWalkDistance = sumStat(\"distance\",currentWalkPages).toFixed(1)\nconst totalCurrentBikeDistance = sumStat(\"distance\", currentBikePages).toFixed(1)\nconst totalPriorDistance = sumStat(\"distance\",priorPages).toFixed(1)\nconst totalPriorWalkDistance = sumStat(\"distance\",priorWalkPages).toFixed(1)\nconst totalPriorBikeDistance = sumStat(\"distance\",priorBikePages).toFixed(1)\n\n/* Calculate the durations (6 values) */\n\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\n\nconst totalCurrentWalkTime = toHours(sumStat(\"duration\",currentWalkPages))\nconst totalCurrentBikeTime = toHours(sumStat(\"duration\",currentBikePages))\nconst totalPriorTime = toHours(sumStat(\"duration\",priorPages))\nconst totalPriorWalkTime = toHours(sumStat(\"duration\",priorWalkPages))\nconst totalPriorBikeTime = toHours(sumStat(\"duration\",priorBikePages))\n\n/* Calculate the speed (4 values) */\n\nconst currentWalkSpeed = (totalCurrentWalkDistance / totalCurrentWalkTime).toFixed(1)\nconst priorWalkSpeed = (totalPriorWalkDistance / totalPriorWalkTime).toFixed(1)\nconst currentBikeSpeed = (totalCurrentBikeDistance / totalCurrentBikeTime).toFixed(1)\nconst priorBikeSpeed = (totalPriorBikeDistance / totalPriorBikeTime).toFixed(1)\n\n/* Count the workouts */\n\nconst currentCount = currentPages.length\nconst priorCount = priorPages.length\nconst currentBikeCount = currentBikePages.length\nconst priorBikeCount = priorBikePages.length\nconst currentWalkCount = currentWalkPages.length\nconst priorWalkCount = priorWalkPages.length\n\n\n\n/* Create an array (list) and add the table rows\n   The first table displays the distance and duration */\n   \nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nrows.push([\"üö∂\", totalCurrentWalkDistance, totalPriorWalkDistance])\nrows.push([\"üö¥\", totalCurrentBikeDistance, totalPriorBikeDistance])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Hours\", totalCurrentTime, totalPriorTime])\nrows.push([\"üö∂\", totalCurrentWalkTime, totalPriorWalkTime])\nrows.push([\"üö¥\", totalCurrentBikeTime, totalPriorBikeTime])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Speed (m/h)\", \"\", \"\"])\nrows.push([\"üö∂\", currentWalkSpeed, priorWalkSpeed])\nrows.push([\"üö¥\", currentBikeSpeed, priorBikeSpeed])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Workouts\", currentCount, priorCount])\nrows.push([\"üö∂\", currentWalkCount, priorWalkCount])\nrows.push([\"üö¥\", currentBikeCount, priorBikeCount])\n\n/* Create the table header */\n\nconst tableHeader = [\"\",\"Current\",\"Prior\"]\n\n/* Display the table */\n\ndv.header(3, \"7 Day Stats\")\ndv.table(tableHeader, rows)",
    "crumbs": [
      "Obsidian",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "obsidian.html",
    "href": "obsidian.html",
    "title": "Obsidian",
    "section": "",
    "text": "DataviewJS: A Gentle Introduction Part 2\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nSelecting Files, Working with Dates\n\n\n\n\n\nFeb 28, 2024\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nSummarizing Information with DataviewJS\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nPresenting and analyzing information in Obsidian\n\n\n\n\n\nOct 16, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive Tables with DataviewJS\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nSelecting Files, Working with Dates\n\n\n\n\n\nOct 14, 2023\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\nDataviewJS: A Gentle Introduction\n\n\n\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nFor Obsidian users who are not programmers\n\n\n\n\n\nOct 11, 2023\n\n\nBrian Carey\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "biscotty's Workshop",
    "section": "",
    "text": "For the love of learning\n\nI‚Äôll write some intro material here. I‚Äôll write some intro material here. I‚Äôll write some intro material here.\nObsidian Articles\nData Science Articles\nCheck out the current workshop.\nThanks to (Shanny-Csik 2022)\n\n\n\n Back to topReferences\n\nShanny-Csik, Samantha. 2022. ‚ÄúAdding a Blog to Your Existing Quarto Website.‚Äù October 24, 2022. https://samanthacsik.github.io/posts/2022-10-24-quarto-blogs/."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "All my favoriate resources",
    "section": "",
    "text": "Back to top"
  }
]