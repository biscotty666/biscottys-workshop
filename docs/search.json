[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "biscotty's Workshop",
    "section": "",
    "text": "For the love of learning\n\nI’ll write some intro material here. I’ll write some intro material here. I’ll write some intro material here.\nCheck out the current workshop.\nThanks to (Shanny-Csik 2022)\n\n\n\n Back to topReferences\n\nShanny-Csik, Samantha. 2022. “Adding a Blog to Your Existing Quarto Website.” October 24, 2022. https://samanthacsik.github.io/posts/2022-10-24-quarto-blogs/."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "biscotty's Workshop",
    "section": "",
    "text": "For the love of learning\n\nI’ll write some intro material here. I’ll write some intro material here. I’ll write some intro material here.\nCheck out the current workshop.\nThanks to (Shanny-Csik 2022)\n\n\n\n Back to topReferences\n\nShanny-Csik, Samantha. 2022. “Adding a Blog to Your Existing Quarto Website.” October 24, 2022. https://samanthacsik.github.io/posts/2022-10-24-quarto-blogs/."
  },
  {
    "objectID": "posts/2024-02-28-trail-mapping-with-python/index.html",
    "href": "posts/2024-02-28-trail-mapping-with-python/index.html",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I’m most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a “you are here”, if you will, or maybe “There, but for the grace of God…”.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my “friends” like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I’d happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I’m doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into “trajectories”, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Posts",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "posts/2024-02-28-trail-mapping-with-python/index.html#introduction",
    "href": "posts/2024-02-28-trail-mapping-with-python/index.html#introduction",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I’m most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a “you are here”, if you will, or maybe “There, but for the grace of God…”.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my “friends” like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I’d happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I’m doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into “trajectories”, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Posts",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "posts/dataviewjs-files-dates/index.html",
    "href": "posts/dataviewjs-files-dates/index.html",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "This article follows an earlier article introducing DataviewJS, which I strongly encourage you to read first. In that article, we learned how to display basic lists with Dataview. In this article, I will cover displaying lists of files in your vault and information in those files. I will also discuss using date ranges in queries and sorting results. Finally I will show how to make a table with multiple fields.\nAs a refresher, to show a list with a header you typed something like\nconst myList = [\n    \"First\",\n    \"Second\",\n    \"Third\"\n]\n\ndv.header(3, \"My List\")\ndv.list(myList)\n.\nThis creates a variable with a camelCase name. The variable contains a list, surrounded by square brackets, separated by commas, with quotations around strings (text). That was easy.\nNow what if I want to list all the files in my vault? I won’t do this, because the list would be crazy long, but just say I did. I would use\nconst fileNameList = dv.pages().file.name\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nThis would give me a bullet-point list of the names of all of the files in my vault. If you don’t have too many files in your vault, go ahead and try. Before narrowing it down to something more specific, let’s look at what is new here. What is pages().file.name? And for that matter, what’s with all the periods?\nLet me explain the periods first. I said that dv is an object. Objects can contain functions, like list(). They can also contain values, often called attributes. The functions and attributes of any object are referred to or accessed by using the name of the object, followed by a period, and then the name of the function or attribute. So the phrase above means: dv is an object that contains a pages() function (the parentheses let you know it is a function). The pages() function selects certain pages and provides attributes for each page, such as the name, links, date created, date modified, etc., in an object called file. In this case I’m choosing to show just the file name. If I wanted links instead, I would do dv.pages().file.link.\nThis dot-notation, using periods, is actually quite nice when you get used to it. Recall that “white space”, including line breaks, is not important in JavaScript, so you will see me often using line breaks before these periods, purely for readability and ease of editing.\nSo let’s see how to narrow things down a little. For the following examples I will use my exercise logs. All the log files are linked to a file called Logs. I can select files that link to this Logs file by writing pages(\"[[Logs]]\"). Note the quotations AND double square brackets. So I can write:\nconst fileNameList = dv.pages(\"[[Logs]]\").file.link\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nI suggest you create some log files in your vault so that you can follow along. Each file should contain, at least, the following fields, some of which we won’t use until we look at tables:\ntopic:: [[Logs]]\ntype:: log\nActivity:: 🚶\nDuration:: 60\nDistance:: 3\nActivityDate:: 2023-10-05\nI use 🚴 as the other activity type. After creating some log files, and the Logs file itself (this file can be empty for now), go ahead and try the JavaScript. You can use this technique to retrieve files on any topic in this way, assuming you have a topic field with the link (really you only need there to be a link).\n\n\n\nLet’s look at some ways we can modify this snippet to make it more useful. First, if you have tried this, and have created log files with various dates, you may notice that they aren’t necessarily displayed in any particular order. I want to make sure they are ordered by the activity date. The pages() object contains a number of functions allowing us to work with data, and sort() is one. sort() takes two arguments, first the name of the field to sort on, and a second argument specifying the sort order, either \"asc\" or \"desc\", for ascending or descending order, respectively.\nUnfortunately, we can’t just add .sort(ActivityDate, \"desc\"). When working with pages() we need to use a special JavaScript syntax. We need to type .sort(a =&gt; a.ActivityDate, \"desc\"). The letter a is arbitrary. I could also write .sort(foo =&gt; foo.ActivityDate, \"desc\") to achieve the same thing. a, or foo, basically serves as temporary variable name for the object you are working with, in this case the page, or note. Then the command says to use the ActivityDate property on each page for sorting. I know it looks a little confusing at first, but you will see this idiom so frequently you will quickly get used to it.\nSo lets sort our logs by date as so:\nconst fileNameList = dv.pages(\"[[Logs]]\")                                                                                                                \n    .sort(b =&gt; b.ActivityDate, \"desc\")                                                                                                                   \n    .ActivityDate\n\ndv.header(3, \"Activity Dates\")\ndv.list(fileNameList)\nNotice how the dot notation allows us to easily add more conditions to our query. ## Selecting by date\nNext, let’s see how we can select logs only for certain dates. To do that, we use the .where() function supplied by pages(). To see only logs since October 3, 2023, I can write\nconst fileNameList = dv.pages(\"[[Logs]]\")\n  .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .ActivityDate                \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nThe syntax for where() is similar to the syntax for sort(). There is an important difference though, because here we are comparing two values. &gt;= means “greater than or equal to”, &lt;= would be “less than or equal to”, etc. This evaluates to either true or false, since the date is either earlier or later than 10/3. This type of true/false value has a special name, boolean, which is good to know. dv provides its own .date() function for simple date manipulation, and I use it here.\nNow that you know how to use where(), let’s do one more thing with it. The code currently takes advantage of the fact that all the logs are linked to the Logs note. I don’t like that, because I might create some logs with a different topic. You may have noticed that all of the log notes have a type:: log. This can be used with .where(), so I can instead write:\nconst fileNameList = dv.pages()\n .where(b =&gt; b.type == \"log\")\n .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n .sort(b =&gt; b.ActivityDate, \"desc\")\n .ActivityDate\n                                                             \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nMany of my queries are based on the type of note, and this is how the note type can be used. Pay attention to the fact that “equal to” requires two equal signs, not one. For completeness, “not equal to” is written !=.\n\n\n\nLists aren’t very interesting, though. Usually you want more than just the name, or one bit of information from a file. So let’s make a table instead with dv.table(). For tables, you must supply an additional list with the column headers. Then you specify the fields that you want using a JavaScript function called map(). It works pretty much the same way as .sort and .where(), it just has a seemingly odd name. map() is used to go through each item in a list and do something with it, in this case, select certain fields from each note. This is called iteration.\nThis table shows the type of activity, distance in miles, duration in minutes and date. I’ve used emojis for column headings. You can see that the fields I want shown are supplied as a list (between square brackets) of the fields I want in the table.\n\nconst headers = [\"🚶/🚴\", \"🗒️\", \"⏱️\", \"📅\"]\n\nconst pages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .map(b =&gt; [\n        b.Activity, \n        b.Distance, \n        b.Duration, \n        b.ActivityDate\n    ])\n                                \n\ndv.header(3, \"Activity since October 3, 2023\")\ndv.table(headers,   pages)\n\n\n\n\nIn the next article I will look at how to make this table dynamic, allowing you to change values directly in the table. I will also talk about relative dates, eg. activity over the last 10 days, or in the 10 days prior to that, or before a certain day but after another day.\nBefore moving on, I strongly encourage you to work with the material covered so far by adding some metadata to your existing notes and creating some queries. I don’t use tags (for now), but if you do, you could do pages(\"#some/tag\") instead of pages(\"[[Logs]]\"). Maybe you have a tag, #fleeting, for example. You could make a list of all your fleeting notes with pages(#fleeting).\nFinally, if you have been reading my Freeing Your Thinking series you may already be doing these examples on a canvas instead of in a note. If you aren’t I encourage you to do so. You can put the code directly into cards on a canvas. Then you can easily see all of your tables in one place, and convert them into notes if you so desire (but why?). Since the end goal will be to have dashboards to view and manage things, you might as well start now. If you have multiple tables on the same canvas, you might want to increase the Refresh Rate in the Dataview settings to prevent the canvas from being too “jumpy” while you type. The default is 2500ms (2.5 seconds). I find that 5 seconds (5000ms) works pretty well for me and the speed I type.\nHappy coding!",
    "crumbs": [
      "Posts",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "posts/dataviewjs-files-dates/index.html#selecting-files",
    "href": "posts/dataviewjs-files-dates/index.html#selecting-files",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "This article follows an earlier article introducing DataviewJS, which I strongly encourage you to read first. In that article, we learned how to display basic lists with Dataview. In this article, I will cover displaying lists of files in your vault and information in those files. I will also discuss using date ranges in queries and sorting results. Finally I will show how to make a table with multiple fields.\nAs a refresher, to show a list with a header you typed something like\nconst myList = [\n    \"First\",\n    \"Second\",\n    \"Third\"\n]\n\ndv.header(3, \"My List\")\ndv.list(myList)\n.\nThis creates a variable with a camelCase name. The variable contains a list, surrounded by square brackets, separated by commas, with quotations around strings (text). That was easy.\nNow what if I want to list all the files in my vault? I won’t do this, because the list would be crazy long, but just say I did. I would use\nconst fileNameList = dv.pages().file.name\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nThis would give me a bullet-point list of the names of all of the files in my vault. If you don’t have too many files in your vault, go ahead and try. Before narrowing it down to something more specific, let’s look at what is new here. What is pages().file.name? And for that matter, what’s with all the periods?\nLet me explain the periods first. I said that dv is an object. Objects can contain functions, like list(). They can also contain values, often called attributes. The functions and attributes of any object are referred to or accessed by using the name of the object, followed by a period, and then the name of the function or attribute. So the phrase above means: dv is an object that contains a pages() function (the parentheses let you know it is a function). The pages() function selects certain pages and provides attributes for each page, such as the name, links, date created, date modified, etc., in an object called file. In this case I’m choosing to show just the file name. If I wanted links instead, I would do dv.pages().file.link.\nThis dot-notation, using periods, is actually quite nice when you get used to it. Recall that “white space”, including line breaks, is not important in JavaScript, so you will see me often using line breaks before these periods, purely for readability and ease of editing.\nSo let’s see how to narrow things down a little. For the following examples I will use my exercise logs. All the log files are linked to a file called Logs. I can select files that link to this Logs file by writing pages(\"[[Logs]]\"). Note the quotations AND double square brackets. So I can write:\nconst fileNameList = dv.pages(\"[[Logs]]\").file.link\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nI suggest you create some log files in your vault so that you can follow along. Each file should contain, at least, the following fields, some of which we won’t use until we look at tables:\ntopic:: [[Logs]]\ntype:: log\nActivity:: 🚶\nDuration:: 60\nDistance:: 3\nActivityDate:: 2023-10-05\nI use 🚴 as the other activity type. After creating some log files, and the Logs file itself (this file can be empty for now), go ahead and try the JavaScript. You can use this technique to retrieve files on any topic in this way, assuming you have a topic field with the link (really you only need there to be a link).",
    "crumbs": [
      "Posts",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "posts/dataviewjs-files-dates/index.html#sorting",
    "href": "posts/dataviewjs-files-dates/index.html#sorting",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "Let’s look at some ways we can modify this snippet to make it more useful. First, if you have tried this, and have created log files with various dates, you may notice that they aren’t necessarily displayed in any particular order. I want to make sure they are ordered by the activity date. The pages() object contains a number of functions allowing us to work with data, and sort() is one. sort() takes two arguments, first the name of the field to sort on, and a second argument specifying the sort order, either \"asc\" or \"desc\", for ascending or descending order, respectively.\nUnfortunately, we can’t just add .sort(ActivityDate, \"desc\"). When working with pages() we need to use a special JavaScript syntax. We need to type .sort(a =&gt; a.ActivityDate, \"desc\"). The letter a is arbitrary. I could also write .sort(foo =&gt; foo.ActivityDate, \"desc\") to achieve the same thing. a, or foo, basically serves as temporary variable name for the object you are working with, in this case the page, or note. Then the command says to use the ActivityDate property on each page for sorting. I know it looks a little confusing at first, but you will see this idiom so frequently you will quickly get used to it.\nSo lets sort our logs by date as so:\nconst fileNameList = dv.pages(\"[[Logs]]\")                                                                                                                \n    .sort(b =&gt; b.ActivityDate, \"desc\")                                                                                                                   \n    .ActivityDate\n\ndv.header(3, \"Activity Dates\")\ndv.list(fileNameList)\nNotice how the dot notation allows us to easily add more conditions to our query. ## Selecting by date\nNext, let’s see how we can select logs only for certain dates. To do that, we use the .where() function supplied by pages(). To see only logs since October 3, 2023, I can write\nconst fileNameList = dv.pages(\"[[Logs]]\")\n  .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .ActivityDate                \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nThe syntax for where() is similar to the syntax for sort(). There is an important difference though, because here we are comparing two values. &gt;= means “greater than or equal to”, &lt;= would be “less than or equal to”, etc. This evaluates to either true or false, since the date is either earlier or later than 10/3. This type of true/false value has a special name, boolean, which is good to know. dv provides its own .date() function for simple date manipulation, and I use it here.\nNow that you know how to use where(), let’s do one more thing with it. The code currently takes advantage of the fact that all the logs are linked to the Logs note. I don’t like that, because I might create some logs with a different topic. You may have noticed that all of the log notes have a type:: log. This can be used with .where(), so I can instead write:\nconst fileNameList = dv.pages()\n .where(b =&gt; b.type == \"log\")\n .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n .sort(b =&gt; b.ActivityDate, \"desc\")\n .ActivityDate\n                                                             \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nMany of my queries are based on the type of note, and this is how the note type can be used. Pay attention to the fact that “equal to” requires two equal signs, not one. For completeness, “not equal to” is written !=.",
    "crumbs": [
      "Posts",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "posts/dataviewjs-files-dates/index.html#a-first-table",
    "href": "posts/dataviewjs-files-dates/index.html#a-first-table",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "Lists aren’t very interesting, though. Usually you want more than just the name, or one bit of information from a file. So let’s make a table instead with dv.table(). For tables, you must supply an additional list with the column headers. Then you specify the fields that you want using a JavaScript function called map(). It works pretty much the same way as .sort and .where(), it just has a seemingly odd name. map() is used to go through each item in a list and do something with it, in this case, select certain fields from each note. This is called iteration.\nThis table shows the type of activity, distance in miles, duration in minutes and date. I’ve used emojis for column headings. You can see that the fields I want shown are supplied as a list (between square brackets) of the fields I want in the table.\n\nconst headers = [\"🚶/🚴\", \"🗒️\", \"⏱️\", \"📅\"]\n\nconst pages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .map(b =&gt; [\n        b.Activity, \n        b.Distance, \n        b.Duration, \n        b.ActivityDate\n    ])\n                                \n\ndv.header(3, \"Activity since October 3, 2023\")\ndv.table(headers,   pages)",
    "crumbs": [
      "Posts",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "posts/dataviewjs-files-dates/index.html#next-steps",
    "href": "posts/dataviewjs-files-dates/index.html#next-steps",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "In the next article I will look at how to make this table dynamic, allowing you to change values directly in the table. I will also talk about relative dates, eg. activity over the last 10 days, or in the 10 days prior to that, or before a certain day but after another day.\nBefore moving on, I strongly encourage you to work with the material covered so far by adding some metadata to your existing notes and creating some queries. I don’t use tags (for now), but if you do, you could do pages(\"#some/tag\") instead of pages(\"[[Logs]]\"). Maybe you have a tag, #fleeting, for example. You could make a list of all your fleeting notes with pages(#fleeting).\nFinally, if you have been reading my Freeing Your Thinking series you may already be doing these examples on a canvas instead of in a note. If you aren’t I encourage you to do so. You can put the code directly into cards on a canvas. Then you can easily see all of your tables in one place, and convert them into notes if you so desire (but why?). Since the end goal will be to have dashboards to view and manage things, you might as well start now. If you have multiple tables on the same canvas, you might want to increase the Refresh Rate in the Dataview settings to prevent the canvas from being too “jumpy” while you type. The default is 2500ms (2.5 seconds). I find that 5 seconds (5000ms) works pretty well for me and the speed I type.\nHappy coding!",
    "crumbs": [
      "Posts",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "posts",
    "section": "",
    "text": "DataviewJS: A Gentle Introduction Part 2\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nSelecting Files, Working with Dates\n\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrail Mapping with Python\n\n\n\nGIS\n\n\nPython\n\n\nGeopandas\n\n\n\nUsing your GPX data with geopandas\n\n\n\nBrian Carey\n\n\nFeb 28, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "All my favoriate resources",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "Posts",
    "section": "",
    "text": "Interactive Tables with DataviewJS\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nSelecting Files, Working with Dates\n\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDataviewJS: A Gentle Introduction Part 2\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nSelecting Files, Working with Dates\n\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSummarizing Information with DataviewJS\n\n\n\nJavascript\n\n\nObsidian\n\n\nPKM\n\n\nDataviewJS\n\n\n\nPresenting and analyzing information in Obsidian\n\n\n\nBrian Carey\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrail Mapping with Python\n\n\n\nGIS\n\n\nPython\n\n\nGeopandas\n\n\n\nUsing your GPX data with geopandas\n\n\n\nBrian Carey\n\n\nFeb 28, 2024\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "blogs/dataviewjs-files-dates/index.html",
    "href": "blogs/dataviewjs-files-dates/index.html",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "This article follows an earlier article introducing DataviewJS, which I strongly encourage you to read first. In that article, we learned how to display basic lists with Dataview. In this article, I will cover displaying lists of files in your vault and information in those files. I will also discuss using date ranges in queries and sorting results. Finally I will show how to make a table with multiple fields.\nAs a refresher, to show a list with a header you typed something like\nconst myList = [\n    \"First\",\n    \"Second\",\n    \"Third\"\n]\n\ndv.header(3, \"My List\")\ndv.list(myList)\n.\nThis creates a variable with a camelCase name. The variable contains a list, surrounded by square brackets, separated by commas, with quotations around strings (text). That was easy.\nNow what if I want to list all the files in my vault? I won’t do this, because the list would be crazy long, but just say I did. I would use\nconst fileNameList = dv.pages().file.name\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nThis would give me a bullet-point list of the names of all of the files in my vault. If you don’t have too many files in your vault, go ahead and try. Before narrowing it down to something more specific, let’s look at what is new here. What is pages().file.name? And for that matter, what’s with all the periods?\nLet me explain the periods first. I said that dv is an object. Objects can contain functions, like list(). They can also contain values, often called attributes. The functions and attributes of any object are referred to or accessed by using the name of the object, followed by a period, and then the name of the function or attribute. So the phrase above means: dv is an object that contains a pages() function (the parentheses let you know it is a function). The pages() function selects certain pages and provides attributes for each page, such as the name, links, date created, date modified, etc., in an object called file. In this case I’m choosing to show just the file name. If I wanted links instead, I would do dv.pages().file.link.\nThis dot-notation, using periods, is actually quite nice when you get used to it. Recall that “white space”, including line breaks, is not important in JavaScript, so you will see me often using line breaks before these periods, purely for readability and ease of editing.\nSo let’s see how to narrow things down a little. For the following examples I will use my exercise logs. All the log files are linked to a file called Logs. I can select files that link to this Logs file by writing pages(\"[[Logs]]\"). Note the quotations AND double square brackets. So I can write:\nconst fileNameList = dv.pages(\"[[Logs]]\").file.link\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nI suggest you create some log files in your vault so that you can follow along. Each file should contain, at least, the following fields, some of which we won’t use until we look at tables:\ntopic:: [[Logs]]\ntype:: log\nActivity:: 🚶\nDuration:: 60\nDistance:: 3\nActivityDate:: 2023-10-05\nI use 🚴 as the other activity type. After creating some log files, and the Logs file itself (this file can be empty for now), go ahead and try the JavaScript. You can use this technique to retrieve files on any topic in this way, assuming you have a topic field with the link (really you only need there to be a link).\n\n\n\nLet’s look at some ways we can modify this snippet to make it more useful. First, if you have tried this, and have created log files with various dates, you may notice that they aren’t necessarily displayed in any particular order. I want to make sure they are ordered by the activity date. The pages() object contains a number of functions allowing us to work with data, and sort() is one. sort() takes two arguments, first the name of the field to sort on, and a second argument specifying the sort order, either \"asc\" or \"desc\", for ascending or descending order, respectively.\nUnfortunately, we can’t just add .sort(ActivityDate, \"desc\"). When working with pages() we need to use a special JavaScript syntax. We need to type .sort(a =&gt; a.ActivityDate, \"desc\"). The letter a is arbitrary. I could also write .sort(foo =&gt; foo.ActivityDate, \"desc\") to achieve the same thing. a, or foo, basically serves as temporary variable name for the object you are working with, in this case the page, or note. Then the command says to use the ActivityDate property on each page for sorting. I know it looks a little confusing at first, but you will see this idiom so frequently you will quickly get used to it.\nSo lets sort our logs by date as so:\nconst fileNameList = dv.pages(\"[[Logs]]\")                                                                                                                \n    .sort(b =&gt; b.ActivityDate, \"desc\")                                                                                                                   \n    .ActivityDate\n\ndv.header(3, \"Activity Dates\")\ndv.list(fileNameList)\nNotice how the dot notation allows us to easily add more conditions to our query. ## Selecting by date\nNext, let’s see how we can select logs only for certain dates. To do that, we use the .where() function supplied by pages(). To see only logs since October 3, 2023, I can write\nconst fileNameList = dv.pages(\"[[Logs]]\")\n  .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .ActivityDate                \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nThe syntax for where() is similar to the syntax for sort(). There is an important difference though, because here we are comparing two values. &gt;= means “greater than or equal to”, &lt;= would be “less than or equal to”, etc. This evaluates to either true or false, since the date is either earlier or later than 10/3. This type of true/false value has a special name, boolean, which is good to know. dv provides its own .date() function for simple date manipulation, and I use it here.\nNow that you know how to use where(), let’s do one more thing with it. The code currently takes advantage of the fact that all the logs are linked to the Logs note. I don’t like that, because I might create some logs with a different topic. You may have noticed that all of the log notes have a type:: log. This can be used with .where(), so I can instead write:\nconst fileNameList = dv.pages()\n .where(b =&gt; b.type == \"log\")\n .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n .sort(b =&gt; b.ActivityDate, \"desc\")\n .ActivityDate\n                                                             \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nMany of my queries are based on the type of note, and this is how the note type can be used. Pay attention to the fact that “equal to” requires two equal signs, not one. For completeness, “not equal to” is written !=.\n\n\n\nLists aren’t very interesting, though. Usually you want more than just the name, or one bit of information from a file. So let’s make a table instead with dv.table(). For tables, you must supply an additional list with the column headers. Then you specify the fields that you want using a JavaScript function called map(). It works pretty much the same way as .sort and .where(), it just has a seemingly odd name. map() is used to go through each item in a list and do something with it, in this case, select certain fields from each note. This is called iteration.\nThis table shows the type of activity, distance in miles, duration in minutes and date. I’ve used emojis for column headings. You can see that the fields I want shown are supplied as a list (between square brackets) of the fields I want in the table.\n\nconst headers = [\"🚶/🚴\", \"🗒️\", \"⏱️\", \"📅\"]\n\nconst pages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .map(b =&gt; [\n        b.Activity, \n        b.Distance, \n        b.Duration, \n        b.ActivityDate\n    ])\n                                \n\ndv.header(3, \"Activity since October 3, 2023\")\ndv.table(headers,   pages)\n\n\n\n\nIn the next article I will look at how to make this table dynamic, allowing you to change values directly in the table. I will also talk about relative dates, eg. activity over the last 10 days, or in the 10 days prior to that, or before a certain day but after another day.\nBefore moving on, I strongly encourage you to work with the material covered so far by adding some metadata to your existing notes and creating some queries. I don’t use tags (for now), but if you do, you could do pages(\"#some/tag\") instead of pages(\"[[Logs]]\"). Maybe you have a tag, #fleeting, for example. You could make a list of all your fleeting notes with pages(#fleeting).\nFinally, if you have been reading my Freeing Your Thinking series you may already be doing these examples on a canvas instead of in a note. If you aren’t I encourage you to do so. You can put the code directly into cards on a canvas. Then you can easily see all of your tables in one place, and convert them into notes if you so desire (but why?). Since the end goal will be to have dashboards to view and manage things, you might as well start now. If you have multiple tables on the same canvas, you might want to increase the Refresh Rate in the Dataview settings to prevent the canvas from being too “jumpy” while you type. The default is 2500ms (2.5 seconds). I find that 5 seconds (5000ms) works pretty well for me and the speed I type.\nHappy coding!",
    "crumbs": [
      "Blogs",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-files-dates/index.html#selecting-files",
    "href": "blogs/dataviewjs-files-dates/index.html#selecting-files",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "This article follows an earlier article introducing DataviewJS, which I strongly encourage you to read first. In that article, we learned how to display basic lists with Dataview. In this article, I will cover displaying lists of files in your vault and information in those files. I will also discuss using date ranges in queries and sorting results. Finally I will show how to make a table with multiple fields.\nAs a refresher, to show a list with a header you typed something like\nconst myList = [\n    \"First\",\n    \"Second\",\n    \"Third\"\n]\n\ndv.header(3, \"My List\")\ndv.list(myList)\n.\nThis creates a variable with a camelCase name. The variable contains a list, surrounded by square brackets, separated by commas, with quotations around strings (text). That was easy.\nNow what if I want to list all the files in my vault? I won’t do this, because the list would be crazy long, but just say I did. I would use\nconst fileNameList = dv.pages().file.name\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nThis would give me a bullet-point list of the names of all of the files in my vault. If you don’t have too many files in your vault, go ahead and try. Before narrowing it down to something more specific, let’s look at what is new here. What is pages().file.name? And for that matter, what’s with all the periods?\nLet me explain the periods first. I said that dv is an object. Objects can contain functions, like list(). They can also contain values, often called attributes. The functions and attributes of any object are referred to or accessed by using the name of the object, followed by a period, and then the name of the function or attribute. So the phrase above means: dv is an object that contains a pages() function (the parentheses let you know it is a function). The pages() function selects certain pages and provides attributes for each page, such as the name, links, date created, date modified, etc., in an object called file. In this case I’m choosing to show just the file name. If I wanted links instead, I would do dv.pages().file.link.\nThis dot-notation, using periods, is actually quite nice when you get used to it. Recall that “white space”, including line breaks, is not important in JavaScript, so you will see me often using line breaks before these periods, purely for readability and ease of editing.\nSo let’s see how to narrow things down a little. For the following examples I will use my exercise logs. All the log files are linked to a file called Logs. I can select files that link to this Logs file by writing pages(\"[[Logs]]\"). Note the quotations AND double square brackets. So I can write:\nconst fileNameList = dv.pages(\"[[Logs]]\").file.link\n\ndv.header(3, \"Log files\")\ndv.list(fileNameList)\nI suggest you create some log files in your vault so that you can follow along. Each file should contain, at least, the following fields, some of which we won’t use until we look at tables:\ntopic:: [[Logs]]\ntype:: log\nActivity:: 🚶\nDuration:: 60\nDistance:: 3\nActivityDate:: 2023-10-05\nI use 🚴 as the other activity type. After creating some log files, and the Logs file itself (this file can be empty for now), go ahead and try the JavaScript. You can use this technique to retrieve files on any topic in this way, assuming you have a topic field with the link (really you only need there to be a link).",
    "crumbs": [
      "Blogs",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-files-dates/index.html#sorting",
    "href": "blogs/dataviewjs-files-dates/index.html#sorting",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "Let’s look at some ways we can modify this snippet to make it more useful. First, if you have tried this, and have created log files with various dates, you may notice that they aren’t necessarily displayed in any particular order. I want to make sure they are ordered by the activity date. The pages() object contains a number of functions allowing us to work with data, and sort() is one. sort() takes two arguments, first the name of the field to sort on, and a second argument specifying the sort order, either \"asc\" or \"desc\", for ascending or descending order, respectively.\nUnfortunately, we can’t just add .sort(ActivityDate, \"desc\"). When working with pages() we need to use a special JavaScript syntax. We need to type .sort(a =&gt; a.ActivityDate, \"desc\"). The letter a is arbitrary. I could also write .sort(foo =&gt; foo.ActivityDate, \"desc\") to achieve the same thing. a, or foo, basically serves as temporary variable name for the object you are working with, in this case the page, or note. Then the command says to use the ActivityDate property on each page for sorting. I know it looks a little confusing at first, but you will see this idiom so frequently you will quickly get used to it.\nSo lets sort our logs by date as so:\nconst fileNameList = dv.pages(\"[[Logs]]\")                                                                                                                \n    .sort(b =&gt; b.ActivityDate, \"desc\")                                                                                                                   \n    .ActivityDate\n\ndv.header(3, \"Activity Dates\")\ndv.list(fileNameList)\nNotice how the dot notation allows us to easily add more conditions to our query. ## Selecting by date\nNext, let’s see how we can select logs only for certain dates. To do that, we use the .where() function supplied by pages(). To see only logs since October 3, 2023, I can write\nconst fileNameList = dv.pages(\"[[Logs]]\")\n  .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .ActivityDate                \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nThe syntax for where() is similar to the syntax for sort(). There is an important difference though, because here we are comparing two values. &gt;= means “greater than or equal to”, &lt;= would be “less than or equal to”, etc. This evaluates to either true or false, since the date is either earlier or later than 10/3. This type of true/false value has a special name, boolean, which is good to know. dv provides its own .date() function for simple date manipulation, and I use it here.\nNow that you know how to use where(), let’s do one more thing with it. The code currently takes advantage of the fact that all the logs are linked to the Logs note. I don’t like that, because I might create some logs with a different topic. You may have noticed that all of the log notes have a type:: log. This can be used with .where(), so I can instead write:\nconst fileNameList = dv.pages()\n .where(b =&gt; b.type == \"log\")\n .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n .sort(b =&gt; b.ActivityDate, \"desc\")\n .ActivityDate\n                                                             \ndv.header(3, \"Activity Dates since October 3, 2023\")\ndv.list(fileNameList)\nMany of my queries are based on the type of note, and this is how the note type can be used. Pay attention to the fact that “equal to” requires two equal signs, not one. For completeness, “not equal to” is written !=.",
    "crumbs": [
      "Blogs",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-files-dates/index.html#a-first-table",
    "href": "blogs/dataviewjs-files-dates/index.html#a-first-table",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "Lists aren’t very interesting, though. Usually you want more than just the name, or one bit of information from a file. So let’s make a table instead with dv.table(). For tables, you must supply an additional list with the column headers. Then you specify the fields that you want using a JavaScript function called map(). It works pretty much the same way as .sort and .where(), it just has a seemingly odd name. map() is used to go through each item in a list and do something with it, in this case, select certain fields from each note. This is called iteration.\nThis table shows the type of activity, distance in miles, duration in minutes and date. I’ve used emojis for column headings. You can see that the fields I want shown are supplied as a list (between square brackets) of the fields I want in the table.\n\nconst headers = [\"🚶/🚴\", \"🗒️\", \"⏱️\", \"📅\"]\n\nconst pages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= dv.date(\"2023-10-03\"))\n    .sort(b =&gt; b.ActivityDate, \"desc\")\n    .map(b =&gt; [\n        b.Activity, \n        b.Distance, \n        b.Duration, \n        b.ActivityDate\n    ])\n                                \n\ndv.header(3, \"Activity since October 3, 2023\")\ndv.table(headers,   pages)",
    "crumbs": [
      "Blogs",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-files-dates/index.html#next-steps",
    "href": "blogs/dataviewjs-files-dates/index.html#next-steps",
    "title": "DataviewJS: A Gentle Introduction Part 2",
    "section": "",
    "text": "In the next article I will look at how to make this table dynamic, allowing you to change values directly in the table. I will also talk about relative dates, eg. activity over the last 10 days, or in the 10 days prior to that, or before a certain day but after another day.\nBefore moving on, I strongly encourage you to work with the material covered so far by adding some metadata to your existing notes and creating some queries. I don’t use tags (for now), but if you do, you could do pages(\"#some/tag\") instead of pages(\"[[Logs]]\"). Maybe you have a tag, #fleeting, for example. You could make a list of all your fleeting notes with pages(#fleeting).\nFinally, if you have been reading my Freeing Your Thinking series you may already be doing these examples on a canvas instead of in a note. If you aren’t I encourage you to do so. You can put the code directly into cards on a canvas. Then you can easily see all of your tables in one place, and convert them into notes if you so desire (but why?). Since the end goal will be to have dashboards to view and manage things, you might as well start now. If you have multiple tables on the same canvas, you might want to increase the Refresh Rate in the Dataview settings to prevent the canvas from being too “jumpy” while you type. The default is 2500ms (2.5 seconds). I find that 5 seconds (5000ms) works pretty well for me and the speed I type.\nHappy coding!",
    "crumbs": [
      "Blogs",
      "DataviewJS: A Gentle Introduction Part 2"
    ]
  },
  {
    "objectID": "blogs/2024-02-28-trail-mapping-with-python/index.html",
    "href": "blogs/2024-02-28-trail-mapping-with-python/index.html",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I’m most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a “you are here”, if you will, or maybe “There, but for the grace of God…”.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my “friends” like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I’d happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I’m doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into “trajectories”, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Blogs",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "blogs/2024-02-28-trail-mapping-with-python/index.html#introduction",
    "href": "blogs/2024-02-28-trail-mapping-with-python/index.html#introduction",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I’m most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a “you are here”, if you will, or maybe “There, but for the grace of God…”.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my “friends” like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I’d happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I’m doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into “trajectories”, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Blogs",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "blogs/gpx-gps-data/index.html",
    "href": "blogs/gpx-gps-data/index.html",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I’m most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a “you are here”, if you will, or maybe “There, but for the grace of God…”.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my “friends” like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I’d happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I’m doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into “trajectories”, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Blogs",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "blogs/gpx-gps-data/index.html#introduction",
    "href": "blogs/gpx-gps-data/index.html#introduction",
    "title": "Trail Mapping with Python",
    "section": "",
    "text": "In the world of Data Science, I’m most strongly drawn to geographically-linked data. Choropleth maps, for example, are about the most powerful way to convey statistical information and get a point across, if you will forgive the intolerable pun. Attaching data to geography somehow makes information more relatable, more personal, and more easily absorbable. It gives people a reference point, a “you are here”, if you will, or maybe “There, but for the grace of God…”.\nI am fortunate to live in New Mexico where I can take beautiful and varied walks, hikes and bike rides nearly every day, which I do. I record most of my excursions with an app on my phone, and I realized recently that I must have lots of data that I can play with to do mapping and analysis. I was pleased to discover that the simple app I use on my phone to track my excursions can easily export the data to GPX format. I had no idea what GPX format was then, but assumed it was some standard, so things looked promising, and off I went.\nThe data I use comes from an app called SportActive. Apps like AllTrails and Strava are wonderful, especially when exploring new places, but they are overkill IMO for simple tracking of daily, and largely repetitive, activities. SportActive simply records my walks and rides, without asking if I want to share my walk with my “friends” like a meal on Facebook. (Disclaimer: I have no financial relationship with SportActive, although if you could arrange such a thing I’d happily change this disclaimer.)\nIn this and two following articles, I will show how the data can be used with Python to map and analyze the GPS information. I will show how to do analyses such as profiling elevations, calculating speeds and durations, identifying pauses, and segmenting paths based on various criteria. This type of analysis, which I’m doing for fun, is the very same as could be used to, for example, study bird migrations or the movement of container ships.\nPython provides many libraries based around the pandas ecosystem which make working with geospatial data easy. GeoPandas extends Pandas to incorporate geometries and coordinate reference systems. GPX data is a series of geolocated points, which is easily handled by geopandas. MovingPandas facilitates turning the point geometries into “trajectories”, allowing for calculations of speed, duration and direction.\nThis article will cover parsing the raw GPS data to a csv file, which I then import into a geopandas GeoDataFrame. From that I will create maps and generate some basic statistical information about the trek such as distance and elevation profiles. These articles assume basic familiarity with Python, experience with Pandas being helpful. An expanded version of the code in the articles can be obtained from my GitHub repository at https://github.com/bisotty666/GPX.",
    "crumbs": [
      "Blogs",
      "Trail Mapping with Python"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-interactive-dynamic-tables/index.html",
    "href": "blogs/dataviewjs-interactive-dynamic-tables/index.html",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "This article follows up on earlier articles in which I showed how to create interactive tables which are automatically updated and can be edited directly in the table. This article will describe how to create summary statistics for data. The statistics on the dashboard update based on the current day.\nAs you can see, I’ve done a bit of rearranging since the last article to make things even more readable. The statistics tables have been re-sized and reformatted for a cleaner display, and I’ve added more information. There are still some tweaks I want to do, but this is a very useful dashboard.\nA quick comment on canvases: since I started working on canvases it’s hard to go back to the 80 characters wide format of a note. Sure, when I’m writing an article or focusing on a bit of code, that format feels very natural. But when doing pretty much anything else, well, it’s just nice to be able to spread out, and not have to open and close files, or page up and down through documents. Using a canvas is like putting all of your current work on your desk, with everything open to the pages you are interested in. In a future article I will show how a dashboard can be used in place of a Daily Note to manage your day.\nHere is the table I will show how to create in this article. As before, you can just skip to the bottom and grab the code if you want. This article explains everything rather thoroughly and introduces some general programming concepts. I think that, if you spend a little time with the material you will find that it is not, as they say, rocket science.\n\nThat’s 22 numbers to calculate! The process isn’t too complicated, but we need to keep track of a lot of things. To avoid a lot of repetition, we will create some custom functions, and you need to learn how to “push” lists into lists.\nLet’s start by writing down what we need to do.\n\nCreate the data sets\n\nGet the logs for current and prior periods\nSeparate by activity\n\nMake a variable and calculate each statistic for current and prior periods\n\ndistance for each activity and total (6 total)\nduration for each activity and total (6 total)\nspeed for each activity (4 total)\ncounts for each activity (6 total)\n\nGenerate the output\n\nCreate the tables’ headers\nGenerate the table rows\nCreate headers for the with workout totals\nDisplay the tables with header elements\n\n\n\n\nFirst, let’s grab the data for the current and prior seven day periods. In the last article I showed how to get the current period. Did you figure out how to get the prior period? One way is to first take the data from the last 14 days, and then remove the most recent 7 days. So we’ll do it like this:\nconst priorPages = dv.pages() \n                    .where(b =&gt; b.type == \"log\")\n                    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n                    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \n\nCreate the currentPages data set as well. Then each needs to be separated by walking and biking. You can do it like this:\nconst currentWalkPages = currentPages\n                    .where(b =&gt; b.Activity == \"🚶\")\nGo ahead and create the rest of the datasets. You need currentBikePages, priorWalkPages and priorBikePages.\n\n\n\nGood programming involves avoiding repetitive tasks. Whenever you need to do the same thing more than once or twice, the standard practice is to make a function.\n\n\nHere is an example of a function we can use. It is arguably overkill to make this a function, but it will provide a good example. A function starts with the keyword function followed by the name you want to use. The name is followed by parentheses which are required, but may be empty. They are used to pass arguments to the function. The function itself is then placed in curly braces. After the function does it’s work, it needs to return some value.\nI have a bunch of numbers in minutes which I want to convert to hours. This is just a matter of dividing by 60 of course, but I also want to round off to one decimal. There is a function toFixed() which can be used on strings. It takes one argument, the number of decimal places you want to round it to. This is the function:\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\nand I use it like this.\nconst totalCurrentTime = toHours( sumStat(\"duration\", pages) )\nOf course, I haven’t created sumStat() yet. To calculate the sum there is a JavaScript function called reduce(). It is used like this:\nreduce(\n    (sum, b) =&gt; sum + b.Distance,\n     0\n)\nThe syntax looks a little complicated, but it’s not so bad if you break it down. reduce() takes two arguments. The first argument is (sum, b) =&gt; sum + b.Distance, which is itself a function with two arguments. The second argument here is our old friend b. In this case, we also need temporary variable called an accumulator. The name of this variable is arbitrary, like b. reduce() will go through each log, adding the value of the Distance field to the accumulator. The second argument to reduce() is just the initial value for the accumulator, which is almost always 0.\nNow I can write the function like this\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    \n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\nI didn’t want to write two separate functions for calculating the sums, instead I use a conditional if statement, which works as you might expect. Notice a few things about this. First, pageValues just saves us adding .values to each if statement. if statements require a condition in parentheses. It must be something that evaluates to a boolean value (true or false, remember). Then, as usual, the block of code you want to execute must be in curly braces. Finally, you almost always want to return something. Once you hit a return statement, nothing else gets executed in the function.\n\n\n\nNow we can create all of our time and distance variables like this:\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\nSpeed is just distance over time, so.\nconst currentWalkSpeed = (\n    totalCurrentWalkDistance / totalCurrentWalkTime\n    )\n    .toFixed(1)\nNotice that I specified to round to one decimal point. To find the total number of workouts it is necessary merely to count the number of pages in each category, since each represents one workout. pages() is a list, or array. Arrays all have an attribute/property called length. So to count all workouts in the last seven days I can just write const currentCount = currentPages.length.\nEverything else is just repetition, since we need 22 values at the end of the day. Any repetitive activity cries out for a new function to encapsulate this repetition, but I’ll leave that for another day. (This is called refactoring.)\n\n\n\n\nThe tables from the last article used a dv.pages() object for the table rows. This time I need to create each table row myself. Each table row is itself a list. So I need a list of lists. It is easy to do this with the push() command, which just adds an item to a list. The item being added can be anything, including a list. I will build the table rows like this:\nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nI have to initialize the variable, because I can’t push anything onto a non-existent list. I used let instead of const. The difference is that a const variable cannot change after it has been created, while one declared with var can. (In older code you will see var instead of let. This still works but let is preferred.)\nSo all that remains is to push each row of the table into the rows variable, create the headers for the table, and use dv.table() to display it. The final code is at the bottom. I strongly suggest, having reached this point, that you try to do this on your own and don’t simply copy and paste my code.\n\n\n\nIf you read through both articles, congratulations. Give yourself a pat on the back. You are doing object-oriented programming in the most widely-used language on the internet. And you have all of the knowledge you need to create rich, useful dashboards.\nHappy coding!\n/* Create data sets  */\n\nconst currentPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\nconst priorPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \nconst currentWalkPages = currentPages\n    .where(b =&gt; b.Activity == \"🚶\")\nconst currentBikePages = currentPages\n    .where(b =&gt; b.Activity == \"🚴\")\nconst priorWalkPages = priorPages\n    .where(b =&gt; b.Activity == \"🚶\")\nconst priorBikePages = priorPages\n    .where(b =&gt; b.Activity == \"🚴\")\n\n/* Function to sum the distances, duration */\n\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    \n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\n\n/* Function to convert minutes to hours */\n\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\n\n\n/* Calculate the distances (6 values) */\n\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\n\nconst totalCurrentWalkDistance = sumStat(\"distance\",currentWalkPages).toFixed(1)\nconst totalCurrentBikeDistance = sumStat(\"distance\", currentBikePages).toFixed(1)\nconst totalPriorDistance = sumStat(\"distance\",priorPages).toFixed(1)\nconst totalPriorWalkDistance = sumStat(\"distance\",priorWalkPages).toFixed(1)\nconst totalPriorBikeDistance = sumStat(\"distance\",priorBikePages).toFixed(1)\n\n/* Calculate the durations (6 values) */\n\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\n\nconst totalCurrentWalkTime = toHours(sumStat(\"duration\",currentWalkPages))\nconst totalCurrentBikeTime = toHours(sumStat(\"duration\",currentBikePages))\nconst totalPriorTime = toHours(sumStat(\"duration\",priorPages))\nconst totalPriorWalkTime = toHours(sumStat(\"duration\",priorWalkPages))\nconst totalPriorBikeTime = toHours(sumStat(\"duration\",priorBikePages))\n\n/* Calculate the speed (4 values) */\n\nconst currentWalkSpeed = (totalCurrentWalkDistance / totalCurrentWalkTime).toFixed(1)\nconst priorWalkSpeed = (totalPriorWalkDistance / totalPriorWalkTime).toFixed(1)\nconst currentBikeSpeed = (totalCurrentBikeDistance / totalCurrentBikeTime).toFixed(1)\nconst priorBikeSpeed = (totalPriorBikeDistance / totalPriorBikeTime).toFixed(1)\n\n/* Count the workouts */\n\nconst currentCount = currentPages.length\nconst priorCount = priorPages.length\nconst currentBikeCount = currentBikePages.length\nconst priorBikeCount = priorBikePages.length\nconst currentWalkCount = currentWalkPages.length\nconst priorWalkCount = priorWalkPages.length\n\n\n\n/* Create an array (list) and add the table rows\n   The first table displays the distance and duration */\n   \nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nrows.push([\"🚶\", totalCurrentWalkDistance, totalPriorWalkDistance])\nrows.push([\"🚴\", totalCurrentBikeDistance, totalPriorBikeDistance])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Hours\", totalCurrentTime, totalPriorTime])\nrows.push([\"🚶\", totalCurrentWalkTime, totalPriorWalkTime])\nrows.push([\"🚴\", totalCurrentBikeTime, totalPriorBikeTime])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Speed (m/h)\", \"\", \"\"])\nrows.push([\"🚶\", currentWalkSpeed, priorWalkSpeed])\nrows.push([\"🚴\", currentBikeSpeed, priorBikeSpeed])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Workouts\", currentCount, priorCount])\nrows.push([\"🚶\", currentWalkCount, priorWalkCount])\nrows.push([\"🚴\", currentBikeCount, priorBikeCount])\n\n/* Create the table header */\n\nconst tableHeader = [\"\",\"Current\",\"Prior\"]\n\n/* Display the table */\n\ndv.header(3, \"7 Day Stats\")\ndv.table(tableHeader, rows)",
    "crumbs": [
      "Blogs",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-interactive-dynamic-tables/index.html#the-data",
    "href": "blogs/dataviewjs-interactive-dynamic-tables/index.html#the-data",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "First, let’s grab the data for the current and prior seven day periods. In the last article I showed how to get the current period. Did you figure out how to get the prior period? One way is to first take the data from the last 14 days, and then remove the most recent 7 days. So we’ll do it like this:\nconst priorPages = dv.pages() \n                    .where(b =&gt; b.type == \"log\")\n                    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n                    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \n\nCreate the currentPages data set as well. Then each needs to be separated by walking and biking. You can do it like this:\nconst currentWalkPages = currentPages\n                    .where(b =&gt; b.Activity == \"🚶\")\nGo ahead and create the rest of the datasets. You need currentBikePages, priorWalkPages and priorBikePages.",
    "crumbs": [
      "Blogs",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-interactive-dynamic-tables/index.html#calculations",
    "href": "blogs/dataviewjs-interactive-dynamic-tables/index.html#calculations",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "Good programming involves avoiding repetitive tasks. Whenever you need to do the same thing more than once or twice, the standard practice is to make a function.\n\n\nHere is an example of a function we can use. It is arguably overkill to make this a function, but it will provide a good example. A function starts with the keyword function followed by the name you want to use. The name is followed by parentheses which are required, but may be empty. They are used to pass arguments to the function. The function itself is then placed in curly braces. After the function does it’s work, it needs to return some value.\nI have a bunch of numbers in minutes which I want to convert to hours. This is just a matter of dividing by 60 of course, but I also want to round off to one decimal. There is a function toFixed() which can be used on strings. It takes one argument, the number of decimal places you want to round it to. This is the function:\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\nand I use it like this.\nconst totalCurrentTime = toHours( sumStat(\"duration\", pages) )\nOf course, I haven’t created sumStat() yet. To calculate the sum there is a JavaScript function called reduce(). It is used like this:\nreduce(\n    (sum, b) =&gt; sum + b.Distance,\n     0\n)\nThe syntax looks a little complicated, but it’s not so bad if you break it down. reduce() takes two arguments. The first argument is (sum, b) =&gt; sum + b.Distance, which is itself a function with two arguments. The second argument here is our old friend b. In this case, we also need temporary variable called an accumulator. The name of this variable is arbitrary, like b. reduce() will go through each log, adding the value of the Distance field to the accumulator. The second argument to reduce() is just the initial value for the accumulator, which is almost always 0.\nNow I can write the function like this\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    \n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\nI didn’t want to write two separate functions for calculating the sums, instead I use a conditional if statement, which works as you might expect. Notice a few things about this. First, pageValues just saves us adding .values to each if statement. if statements require a condition in parentheses. It must be something that evaluates to a boolean value (true or false, remember). Then, as usual, the block of code you want to execute must be in curly braces. Finally, you almost always want to return something. Once you hit a return statement, nothing else gets executed in the function.\n\n\n\nNow we can create all of our time and distance variables like this:\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\nSpeed is just distance over time, so.\nconst currentWalkSpeed = (\n    totalCurrentWalkDistance / totalCurrentWalkTime\n    )\n    .toFixed(1)\nNotice that I specified to round to one decimal point. To find the total number of workouts it is necessary merely to count the number of pages in each category, since each represents one workout. pages() is a list, or array. Arrays all have an attribute/property called length. So to count all workouts in the last seven days I can just write const currentCount = currentPages.length.\nEverything else is just repetition, since we need 22 values at the end of the day. Any repetitive activity cries out for a new function to encapsulate this repetition, but I’ll leave that for another day. (This is called refactoring.)",
    "crumbs": [
      "Blogs",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-interactive-dynamic-tables/index.html#generate-the-output",
    "href": "blogs/dataviewjs-interactive-dynamic-tables/index.html#generate-the-output",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "The tables from the last article used a dv.pages() object for the table rows. This time I need to create each table row myself. Each table row is itself a list. So I need a list of lists. It is easy to do this with the push() command, which just adds an item to a list. The item being added can be anything, including a list. I will build the table rows like this:\nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nI have to initialize the variable, because I can’t push anything onto a non-existent list. I used let instead of const. The difference is that a const variable cannot change after it has been created, while one declared with var can. (In older code you will see var instead of let. This still works but let is preferred.)\nSo all that remains is to push each row of the table into the rows variable, create the headers for the table, and use dv.table() to display it. The final code is at the bottom. I strongly suggest, having reached this point, that you try to do this on your own and don’t simply copy and paste my code.",
    "crumbs": [
      "Blogs",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-interactive-dynamic-tables/index.html#final-thoughts",
    "href": "blogs/dataviewjs-interactive-dynamic-tables/index.html#final-thoughts",
    "title": "Summarizing Information with DataviewJS",
    "section": "",
    "text": "If you read through both articles, congratulations. Give yourself a pat on the back. You are doing object-oriented programming in the most widely-used language on the internet. And you have all of the knowledge you need to create rich, useful dashboards.\nHappy coding!\n/* Create data sets  */\n\nconst currentPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\nconst priorPages = dv.pages() \n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(14, \"days\"))\n    .where(b =&gt; b.ActivityDate &lt;= moment().subtract(7, \"days\")) \nconst currentWalkPages = currentPages\n    .where(b =&gt; b.Activity == \"🚶\")\nconst currentBikePages = currentPages\n    .where(b =&gt; b.Activity == \"🚴\")\nconst priorWalkPages = priorPages\n    .where(b =&gt; b.Activity == \"🚶\")\nconst priorBikePages = priorPages\n    .where(b =&gt; b.Activity == \"🚴\")\n\n/* Function to sum the distances, duration */\n\nfunction sumStat (stat, thePages) {\n    const pageValues = thePages.values\n    \n    if (stat == \"duration\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Duration, 0)\n    }\n    if (stat == \"distance\") {\n        return pageValues\n          .reduce((sum, b) =&gt; sum + b.Distance, 0)\n    }\n}\n\n/* Function to convert minutes to hours */\n\nfunction toHours (time) {\n return (time / 60).toFixed(1)\n}\n\n\n/* Calculate the distances (6 values) */\n\nconst totalCurrentDistance = sumStat( \"distance\", currentPages ).toFixed(1)\n\nconst totalCurrentWalkDistance = sumStat(\"distance\",currentWalkPages).toFixed(1)\nconst totalCurrentBikeDistance = sumStat(\"distance\", currentBikePages).toFixed(1)\nconst totalPriorDistance = sumStat(\"distance\",priorPages).toFixed(1)\nconst totalPriorWalkDistance = sumStat(\"distance\",priorWalkPages).toFixed(1)\nconst totalPriorBikeDistance = sumStat(\"distance\",priorBikePages).toFixed(1)\n\n/* Calculate the durations (6 values) */\n\nconst totalCurrentTime = toHours( sumStat( \"duration\", currentPages ) )\n\nconst totalCurrentWalkTime = toHours(sumStat(\"duration\",currentWalkPages))\nconst totalCurrentBikeTime = toHours(sumStat(\"duration\",currentBikePages))\nconst totalPriorTime = toHours(sumStat(\"duration\",priorPages))\nconst totalPriorWalkTime = toHours(sumStat(\"duration\",priorWalkPages))\nconst totalPriorBikeTime = toHours(sumStat(\"duration\",priorBikePages))\n\n/* Calculate the speed (4 values) */\n\nconst currentWalkSpeed = (totalCurrentWalkDistance / totalCurrentWalkTime).toFixed(1)\nconst priorWalkSpeed = (totalPriorWalkDistance / totalPriorWalkTime).toFixed(1)\nconst currentBikeSpeed = (totalCurrentBikeDistance / totalCurrentBikeTime).toFixed(1)\nconst priorBikeSpeed = (totalPriorBikeDistance / totalPriorBikeTime).toFixed(1)\n\n/* Count the workouts */\n\nconst currentCount = currentPages.length\nconst priorCount = priorPages.length\nconst currentBikeCount = currentBikePages.length\nconst priorBikeCount = priorBikePages.length\nconst currentWalkCount = currentWalkPages.length\nconst priorWalkCount = priorWalkPages.length\n\n\n\n/* Create an array (list) and add the table rows\n   The first table displays the distance and duration */\n   \nlet rows = []\nrows.push([\"Miles\", totalCurrentDistance, totalPriorDistance])\nrows.push([\"🚶\", totalCurrentWalkDistance, totalPriorWalkDistance])\nrows.push([\"🚴\", totalCurrentBikeDistance, totalPriorBikeDistance])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Hours\", totalCurrentTime, totalPriorTime])\nrows.push([\"🚶\", totalCurrentWalkTime, totalPriorWalkTime])\nrows.push([\"🚴\", totalCurrentBikeTime, totalPriorBikeTime])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Speed (m/h)\", \"\", \"\"])\nrows.push([\"🚶\", currentWalkSpeed, priorWalkSpeed])\nrows.push([\"🚴\", currentBikeSpeed, priorBikeSpeed])\nrows.push([\"\",\"\",\"\"])\nrows.push([\"Workouts\", currentCount, priorCount])\nrows.push([\"🚶\", currentWalkCount, priorWalkCount])\nrows.push([\"🚴\", currentBikeCount, priorBikeCount])\n\n/* Create the table header */\n\nconst tableHeader = [\"\",\"Current\",\"Prior\"]\n\n/* Display the table */\n\ndv.header(3, \"7 Day Stats\")\ndv.table(tableHeader, rows)",
    "crumbs": [
      "Blogs",
      "Summarizing Information with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-summaries-statistics/index.html",
    "href": "blogs/dataviewjs-summaries-statistics/index.html",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "This article is a follow-up to my Gentle Introduction to DataviewJS articles, and assumes that you have read them. It is written for anglers, but if you just want the fish you can Tldr; your way to the bottom an just grab the code. Even if you are here to learn how to fish, depending on your learning style, you may want to take a look at the complete code first before this walk-through.\nWe are now ready to start building a fully dynamic and interactive dashboard to manage the exercise logs. In this case, I’m tracking the following:\n\ntype of activity\ndistance\nduration\ndate of activity\nroute\n\nI have optional fields for notes and, as you can see, for images. Summary tables are generated using calculated values. The entire canvas updates automatically to the current day.\nThis example could easily be extended for tracking anything which includes numerical data and images. Imagine a research project, for example, where observations are taken combining numerical data, textual observations, and photos. Actually creating the log entries, thanks to Metadata Menu and Unique Notes, takes almost no time. You can read about how to do this here.\nIn this article, I’ll focus on creating this dynamic table.\n\nAppropriate widgets are provided allowing for direct editing or the use of popup modals for multi-select fields and dates. The list will display all logs over the last 7 days, so different logs will appear depending on the day.\nTo do this, we will use the excellent JavaScript functionality provided by Metadata Menu. It would be more interesting were you to create a bunch of logs (notes) covering a date range of at least three months and follow along. They should all contain the following fields:\n\ntopic\ntype\nRoute\nActivity\nDuration\nDistance\nNote\nImage\nLink\n\n\n\n\nThroughout this dashboard I work with time. It is natural to want to look at time periods of weeks and months, and to compare current periods to prior periods of the same length. We, just as naturally, compare a week starting Monday or Sunday to a prior week starting on the same day. And we compare February to January. This is often a good thing, because it fits the way people naturally think.\nBut if you are really looking at the numbers, you quickly see the flaw in comparing time periods this way. You can’t compare a complete week to the prior week until the end of the week. To get around this, people use week-to-date, or quite commonly month-to-date. For months the problem is worse, as in the case of Feb/Jan comparison that’s 28 days compared to 31 days. That’s more than a 10% difference in days, and therefor in data!\nA simple way around this, and one which provides better analysis, is to use rolling windows of time. Any seven day period contains every day of the week, and so comparing two of any such periods valid (and complete) week-to-week comparisons. For months, you can compare any 30 (or 28) day period to the prior period of equal length, so you get a full, month-long picture with apples-to-apples data (that’s a technical term😉).\nIn the first article I introduced moment(), an object provided by Dataview (by MomentJS actually). This makes time math easy. moment() itself means today, now, this very second. If you want the date/time two days ago, you can subtract two days with moment().subtract(2, \"days\"). I’ll leave it as an exercise to the reader to figure out how to find the date two months ago.\nIn order to use moment() for any date other than now, you need to write, eg., moment(new Date(\"2023-10-20\"). We will do this so that we can format the date differently using the format() function in moment(). format() wants an argument, a date format string. I don’t need to see the year, and a 2-digit month is fine and shorter. On the other hand, seeing the day of the week would be useful. The format string to produce “10/10 Tue” is “MM/DD ddd”. ### Challenge As an exercise, you might pause here and think about how to display “two days ago” in the format “10/10 Tue”. You have all the knowledge you need. Think about chaining commands together with the period. ### Solution\nHere is a solution:\nconst dateFormat = \"MM/DD ddd\" const twoDaysAgo =\nmoment() .subtract(2, \"days\") .format(dateFormat)\n\ndv.paragraph(twoDaysAgo)\nWhen writing, and especially reading, code, formatting is important. I could have written\nconst twoDaysAgo = moment().subtract(2, \"days\").format(dateFormat)\nbut it is much less clear what is going on. If you are trying to understand a piece of code, start by reformatting. ## Asynchronous Functions\nMost computer programs execute line by line, with each line completing before moving on to the next line. Normally this is what you want. However, as the quantity of data commonly worked with increases geometrically, and the fact that it is often distributed widely across the internet, applications which require fetching data can easily grind to a halt due to a slow internet connection, slow servers, large quantities, etc. To overcome this problems, some functions are executed asynchronously. When an asynchronous function is executed, it doesn’t return the actual data. Instead, it returns what is called a promise. That allows the program to continue executing while the data is being fetched. It will continue execution until the data is actually required, at which point it will wait (not freeze).\nIn practice this is quite easy, involving the use of two new key words: async and await. The first, async, is added to the function definition, and the second, await, is added before any data fetching. That’s all you need to know so that you will understand the words when you see them.\n\n\n\nMetadata Menu provides an asynchronous function for making the tables interactive. To use the function, you must import it with\nconst {fieldModifier: f} = this.app.plugins.plugins[\"metadata-menu\"].api\nUsing the curly braces like this is called deconstructing a variable or function. This means that somewhere there is a function called fieldModifier. The : f is just an alias, so that every time you use the function you don’t need to write out fieldModifier, you can just write f.\nThe other part is interesting. Take it step by step. this is the root directory of your vault. app is the hidden obsidian directory, inside of which there is, you guessed it, a plugins directory with an entry called metadata-menu. The rest, plugins[\"metadata-menu\"].api says to look in the metadata-menu directory for something called api. This object will contain a function called fieldModifier, which we can now refer to simply as f.\nfieldModifier(), which is f() to us now, is used in map() and takes three arguments: the dv object, whatever temporary variable you are using in map() (we have been using b), and the name of the field we want. Were it a normal function you would write\ndataviewjs dv.pages()     \n  .map(b=&gt;[p.ActivityDate, \n  f(dv, b, \"Activity\"),\n  ]\nSince this fetching of date is asynchronous, you have to use the key words async/await here, so\ndataviewjs dv.pages()     \n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ]\nThe entire section containing pages().map needs to be wrapped in an asynchronous function called Promise.all(), which must be (a)waited for and returns, unsurprisingly, a promise.\nawait Promise.all(dv.pages()\n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ])\n\n\n\nNow, lets finally take a look at the entire code that creates the dashboard. Take some time to read through it. Everything should be understandable at this point.\nconst {fieldModifier: f} =\nthis.app.plugins.plugins\\[\"metadata-menu\"\\].api\n\nconst dateFormat = \"MM/DD ddd\"\n\ndv.header(3, \"7 Day Details\")\n\ndv.table(\\[\"🗓️\",\"🚶🚴\", \"📓\", \"⏱️\", \"🗺️\"\\],\n\nawait Promise.all(dv.pages()\n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\n    .sort(p =&gt; p.ActivityDate, \"desc\")\n    .map(async b=&gt;[\n        moment(new Date(b.ActivityDate)).format(dateFormat),\n        await f(dv, b, \"Activity\"), \n        await f(dv, b, \"Distance\"), \n        await f(dv, b, \"Duration\"), \n        await f(dv, b, \"Route\"),\n    ]\n  )\n)\n\n\n\nIn the next article I will explain how to generate summary information like totals and averages for display on the dashboard. In the mean time I strongly suggest that you do two things:\n\nAdd images to some of your logs and create the table for the Gallery section of the dashboard\nTurn some of your existing Dataview tables into DataviewJS tables. Or, at least, make some new ones from your own information\nSpend some time working with date ranges. In this example, we selected the past seven days. How can you select the seven days prior to that? (Hint: you need to chain together two where() clauses.)\nCan you create a month-to-date view? There are various ways to do it, but it’s helpful to know that you can do moment().startOf('month') to grab the first day of the month. Check out the documentation for more possibilities.\n\nHappy coding!",
    "crumbs": [
      "Blogs",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-summaries-statistics/index.html#introduction",
    "href": "blogs/dataviewjs-summaries-statistics/index.html#introduction",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "This article is a follow-up to my Gentle Introduction to DataviewJS articles, and assumes that you have read them. It is written for anglers, but if you just want the fish you can Tldr; your way to the bottom an just grab the code. Even if you are here to learn how to fish, depending on your learning style, you may want to take a look at the complete code first before this walk-through.\nWe are now ready to start building a fully dynamic and interactive dashboard to manage the exercise logs. In this case, I’m tracking the following:\n\ntype of activity\ndistance\nduration\ndate of activity\nroute\n\nI have optional fields for notes and, as you can see, for images. Summary tables are generated using calculated values. The entire canvas updates automatically to the current day.\nThis example could easily be extended for tracking anything which includes numerical data and images. Imagine a research project, for example, where observations are taken combining numerical data, textual observations, and photos. Actually creating the log entries, thanks to Metadata Menu and Unique Notes, takes almost no time. You can read about how to do this here.\nIn this article, I’ll focus on creating this dynamic table.\n\nAppropriate widgets are provided allowing for direct editing or the use of popup modals for multi-select fields and dates. The list will display all logs over the last 7 days, so different logs will appear depending on the day.\nTo do this, we will use the excellent JavaScript functionality provided by Metadata Menu. It would be more interesting were you to create a bunch of logs (notes) covering a date range of at least three months and follow along. They should all contain the following fields:\n\ntopic\ntype\nRoute\nActivity\nDuration\nDistance\nNote\nImage\nLink",
    "crumbs": [
      "Blogs",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-summaries-statistics/index.html#time-math",
    "href": "blogs/dataviewjs-summaries-statistics/index.html#time-math",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "Throughout this dashboard I work with time. It is natural to want to look at time periods of weeks and months, and to compare current periods to prior periods of the same length. We, just as naturally, compare a week starting Monday or Sunday to a prior week starting on the same day. And we compare February to January. This is often a good thing, because it fits the way people naturally think.\nBut if you are really looking at the numbers, you quickly see the flaw in comparing time periods this way. You can’t compare a complete week to the prior week until the end of the week. To get around this, people use week-to-date, or quite commonly month-to-date. For months the problem is worse, as in the case of Feb/Jan comparison that’s 28 days compared to 31 days. That’s more than a 10% difference in days, and therefor in data!\nA simple way around this, and one which provides better analysis, is to use rolling windows of time. Any seven day period contains every day of the week, and so comparing two of any such periods valid (and complete) week-to-week comparisons. For months, you can compare any 30 (or 28) day period to the prior period of equal length, so you get a full, month-long picture with apples-to-apples data (that’s a technical term😉).\nIn the first article I introduced moment(), an object provided by Dataview (by MomentJS actually). This makes time math easy. moment() itself means today, now, this very second. If you want the date/time two days ago, you can subtract two days with moment().subtract(2, \"days\"). I’ll leave it as an exercise to the reader to figure out how to find the date two months ago.\nIn order to use moment() for any date other than now, you need to write, eg., moment(new Date(\"2023-10-20\"). We will do this so that we can format the date differently using the format() function in moment(). format() wants an argument, a date format string. I don’t need to see the year, and a 2-digit month is fine and shorter. On the other hand, seeing the day of the week would be useful. The format string to produce “10/10 Tue” is “MM/DD ddd”. ### Challenge As an exercise, you might pause here and think about how to display “two days ago” in the format “10/10 Tue”. You have all the knowledge you need. Think about chaining commands together with the period. ### Solution\nHere is a solution:\nconst dateFormat = \"MM/DD ddd\" const twoDaysAgo =\nmoment() .subtract(2, \"days\") .format(dateFormat)\n\ndv.paragraph(twoDaysAgo)\nWhen writing, and especially reading, code, formatting is important. I could have written\nconst twoDaysAgo = moment().subtract(2, \"days\").format(dateFormat)\nbut it is much less clear what is going on. If you are trying to understand a piece of code, start by reformatting. ## Asynchronous Functions\nMost computer programs execute line by line, with each line completing before moving on to the next line. Normally this is what you want. However, as the quantity of data commonly worked with increases geometrically, and the fact that it is often distributed widely across the internet, applications which require fetching data can easily grind to a halt due to a slow internet connection, slow servers, large quantities, etc. To overcome this problems, some functions are executed asynchronously. When an asynchronous function is executed, it doesn’t return the actual data. Instead, it returns what is called a promise. That allows the program to continue executing while the data is being fetched. It will continue execution until the data is actually required, at which point it will wait (not freeze).\nIn practice this is quite easy, involving the use of two new key words: async and await. The first, async, is added to the function definition, and the second, await, is added before any data fetching. That’s all you need to know so that you will understand the words when you see them.",
    "crumbs": [
      "Blogs",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-summaries-statistics/index.html#metadata-menu",
    "href": "blogs/dataviewjs-summaries-statistics/index.html#metadata-menu",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "Metadata Menu provides an asynchronous function for making the tables interactive. To use the function, you must import it with\nconst {fieldModifier: f} = this.app.plugins.plugins[\"metadata-menu\"].api\nUsing the curly braces like this is called deconstructing a variable or function. This means that somewhere there is a function called fieldModifier. The : f is just an alias, so that every time you use the function you don’t need to write out fieldModifier, you can just write f.\nThe other part is interesting. Take it step by step. this is the root directory of your vault. app is the hidden obsidian directory, inside of which there is, you guessed it, a plugins directory with an entry called metadata-menu. The rest, plugins[\"metadata-menu\"].api says to look in the metadata-menu directory for something called api. This object will contain a function called fieldModifier, which we can now refer to simply as f.\nfieldModifier(), which is f() to us now, is used in map() and takes three arguments: the dv object, whatever temporary variable you are using in map() (we have been using b), and the name of the field we want. Were it a normal function you would write\ndataviewjs dv.pages()     \n  .map(b=&gt;[p.ActivityDate, \n  f(dv, b, \"Activity\"),\n  ]\nSince this fetching of date is asynchronous, you have to use the key words async/await here, so\ndataviewjs dv.pages()     \n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ]\nThe entire section containing pages().map needs to be wrapped in an asynchronous function called Promise.all(), which must be (a)waited for and returns, unsurprisingly, a promise.\nawait Promise.all(dv.pages()\n  .map(async b=&gt;[\n    p.ActivityDate,\n    await f(dv, b, \"Activity\"),\n    ])",
    "crumbs": [
      "Blogs",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-summaries-statistics/index.html#the-table",
    "href": "blogs/dataviewjs-summaries-statistics/index.html#the-table",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "Now, lets finally take a look at the entire code that creates the dashboard. Take some time to read through it. Everything should be understandable at this point.\nconst {fieldModifier: f} =\nthis.app.plugins.plugins\\[\"metadata-menu\"\\].api\n\nconst dateFormat = \"MM/DD ddd\"\n\ndv.header(3, \"7 Day Details\")\n\ndv.table(\\[\"🗓️\",\"🚶🚴\", \"📓\", \"⏱️\", \"🗺️\"\\],\n\nawait Promise.all(dv.pages()\n    .where(b =&gt; b.type == \"log\")\n    .where(b =&gt; b.ActivityDate &gt;= moment().subtract(7, \"days\"))\n    .sort(p =&gt; p.ActivityDate, \"desc\")\n    .map(async b=&gt;[\n        moment(new Date(b.ActivityDate)).format(dateFormat),\n        await f(dv, b, \"Activity\"), \n        await f(dv, b, \"Distance\"), \n        await f(dv, b, \"Duration\"), \n        await f(dv, b, \"Route\"),\n    ]\n  )\n)",
    "crumbs": [
      "Blogs",
      "Interactive Tables with DataviewJS"
    ]
  },
  {
    "objectID": "blogs/dataviewjs-summaries-statistics/index.html#next-steps",
    "href": "blogs/dataviewjs-summaries-statistics/index.html#next-steps",
    "title": "Interactive Tables with DataviewJS",
    "section": "",
    "text": "In the next article I will explain how to generate summary information like totals and averages for display on the dashboard. In the mean time I strongly suggest that you do two things:\n\nAdd images to some of your logs and create the table for the Gallery section of the dashboard\nTurn some of your existing Dataview tables into DataviewJS tables. Or, at least, make some new ones from your own information\nSpend some time working with date ranges. In this example, we selected the past seven days. How can you select the seven days prior to that? (Hint: you need to chain together two where() clauses.)\nCan you create a month-to-date view? There are various ways to do it, but it’s helpful to know that you can do moment().startOf('month') to grab the first day of the month. Check out the documentation for more possibilities.\n\nHappy coding!",
    "crumbs": [
      "Blogs",
      "Interactive Tables with DataviewJS"
    ]
  }
]