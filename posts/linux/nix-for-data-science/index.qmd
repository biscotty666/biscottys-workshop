---
title: Nix for Data Scientists
subtitle: Nix your venvs and skip pip
description: Installing and maintaining multiple versions of libraries, whether in Python or R, is best managed with Nix
image: NixosWinter.png
date: 05-21-2025
categories: [Linux, Data Science, Nix, Python]
author: Brian Carey
---
# Package Management

Imagine having a fully provisioned data science environment with all dependencies and a configured IDE from scratch by simply placing a single file in a directory and running a single command. Even better, what if all you had to do was to enter the directory and not run any command. Imagine you could add, remove, and upgrade libraries without saying a little prayer that you don't get the dreaded message that a compatible set of dependencies could not be found. That's Nix.

My computer is very clean. I don't have any IDEs installed, nor any data science libraries. Well, that's not really true. Actually I have many versions of each of these installed on my system. But they are only accessible in the directories to which they pertain, although they are not installed in the directory live virtual environments. Even though Python is installed system-wide on my computer, each directory even has its own version of Python. 

Package management for data scientists working in Python has been notoriously difficult. Pip, Conda, Miniconda, Mamba, ux, poetry, venvwrapper, Docker ... the list goes on of the different package managers and solutions are available. They all work, mostly. But they all break, occasionally. None are truly reproducible, and they are all prone to the eventual library conflicts, when one package upgrades its own dependencies, and the upgraded dependencies aren't compatible with another package. Then you get notified that the package manager can't figure out a proper set of packages to meet all requirements, and the fun begins.

To be fair, package management is a complex problem when dozens of packages, often with dependencies shared with other packages, need to be installed *and maintained*. Furthermore, work done must be "portable" to other computers, which must have all of the same dependencies available. I should say, it is a complex problem *using the traditional FHS paradigm*. I have [written about](../nix-docker-fhs/index.qmd) the problems caused by the FHS, and the gymnastics required to work around its limitations. The basic problem is that the FHS does not easily accommodate multiple versions of the same package, and packages rely heavily on shared libraries. Nix simply sidesteps these problems by installing everything needed by a package, not relying on anything else being installed elsewhere.

While R libraries have proven significantly less problematic historically, backward-compatibility is not guaranteed across major releases. And there is still the question of portability.

Virtual environments go some way to resolve these problems. Instead of installing packages system-wide, it installs them in a subdirectory in the project folder. When the virtual environment is active, all relevant environment variables are set to point to these local packages. This way there are no version conflicts between different projects on the same machine. But many problems still remain. Firstly, it doesn't solve the problem of version conflicts among packages within the project itself. Even with an accompanying `requirements.txt`, there is no guarantee that someone else will get the exact same libraries as were used in the original project. Docker solves some of these problems, but requires a special process be running to manage the container, as well as a full, separate operating system.

With Nix, a fully provisioned development environment is declared in a text file, which is basically a list of packages you want, although it is actually a functional program(!). It defines a graph. This file can create the development environment automatically when you enter the directory. Within this directory, and any sub-directories, you have access to all the libraries and tools you have declared, even IDEs such as jupyter or vscode. Nothing is installed system-wide, and outside of the directory you do not have access to the packages in the directory. Another directory can have an entirely different set of packages, with potentially entirely different version numbers for packages, and there is no conflict.

Nix works very differently. Everything in Nix gets placed in a single `/nix/store` directory. Nix prepends the hash value of the package/library (called derivations) to the filenames, ensuring no collisions between different versions of any particular library. Nix defines a graph of dependencies for each package, and installs all requirements, not relying on shared libraries (although it does use hard links to reduce storage requirements).

Below, I provide an example of a flake for Python. By placing this file in a directory and running `nix develop`, you will have Jupyter Lab, VS Code with relevant extensions, and some basic data science libraries. To "install" more packages, just add them to the list and run `nix develop` again. Even better, install [direnv](https://direnv.net/docs/installation.html), and the environment will automatically load when you enter the directory and unload when you leave it. 

Nix can be installed on Linux, Mac, or Windows with WSL. Official installation instructions can be found [here](https://nixos.org/download/), but I recommend using [Zero to Nix](https://zero-to-nix.com/start/install/) to install Nix because it will configure the flakes feature for you. Installation boils down to running a simple command. Once you have it installed, try typing `nix shell nixpkgs#floorp` to try out a fun web browser. When you are done, exit the shell and program disappears. Once it is installed, you can use it as the package manager for your system if you want. (I have heard that many Mac users prefer it to homebrew.)


```flake.nix
{
  description = "Python Data Science";
  inputs = {
    nixpkgs = {
      url = "github:nixos/nixpkgs/nixos-unstable";
    };
    flake-utils = {
      url = "github:numtide/flake-utils";
    };
  };
  outputs = { nixpkgs, flake-utils, ... }: flake-utils.lib.eachDefaultSystem (system:
    let
      pkgs = import nixpkgs {
        inherit system;
        config.allowUnfree = true;
      };
      myvscode = pkgs.vscode-with-extensions.override {
        vscodeExtensions = (with pkgs.vscode-extensions; [
        equinusocio.vsc-material-theme
        equinusocio.vsc-material-theme-icons
        vscodevim.vim
        ms-python.python
        ms-python.vscode-pylance
        ms-toolsai.jupyter
        ms-toolsai.jupyter-renderers
        ]);
      };
    in {
      devShell = pkgs.mkShell {
        name = "python-venv";
        venvDir = "./.venv";
        buildInputs = with pkgs; [
          tmux
          myvscode
          (python3.withPackages(ps: with ps; [
            ipython
            pip
            jupyter
            widgetsnbextension
            jupyter-nbextensions-configurator
            jedi-language-server
            ipywidgets
            mypy
            notebook
            pandas
            numpy
            matplotlib
            seaborn
          ]))
        ];
        postVenvCreation = ''
          unset SOURCE_DATE_EPOCH
          pip install -r requirements.txt
        '';

        shellHook = ''
            # export BROWSER=brave
            # Tells pip to put packages into $PIP_PREFIX instead of the usual locations.
            export PIP_PREFIX=$(pwd)/_build/pip_packages
            export PYTHONPATH="$PIP_PREFIX/${pkgs.python3.sitePackages}:$PYTHONPATH"
            export PATH="$PIP_PREFIX/bin:$PATH"
            unset SOURCE_DATE_EPOCH
            # jupyter lab  # uncomment to automatically launch jupyter
        '';

        postShellHook = ''
          # allow pip to install wheels
          unset SOURCE_DATE_EPOCH
        '';
      };
    }
  );
}

```

