---
title: Nix for Data Science
subtitle: Nix your venvs and skip pip
description: Installing and maintaining multiple versions of libraries, whether in Python or R, is better managed with Nix than virtual environments
image: NixosWinter.png
date: 05-21-2025
categories: [Linux, Data Science, Nix, Python]
author: Brian Carey
---
# Package Management

Package management for data scientists working in Python has been notoriously difficult. Pip, Conda, Miniconda, Mamba, ux, poetry, venvwrapper, Docker ... the list goes on of the different package managers available for Python. They all work, mostly. But they all break, occasionally. None are truly reproducible, and they are all prone to the eventual library conflicts, when one library upgrades its own dependencies, and the upgraded dependency is incompatible with another library. Then you get notified that the package manager can't figure out a proper set of packages to meet all requirements. Then the fun begins.

With Nix, a fully provisioned development environment is declared in a text file, which is basically a list of packages you want. This file can create the development environment automatically when you enter the directory. Within this directory, and any sub-directories, you have access to all the libraries and tools you have declared, even IDEs such as jupyter or vscode. Nothing is installed system-wide, and outside of the directory you do not have access to the packages in the directory. Another directory can have an entirely different set of packages, with potentially entirely different version numbers for packages, and there is no conflict.

To be fair, package management is a complex problem when dozens of packages, often with dependencies shared with other packages, need to be installed *and maintained*. Furthermore, work done must be "portable" to other computers, which must have all of the same dependencies available. I should say, it is a complex problem *using the traditional FHS paradigm*. I have [written about](../nix-docker-fhs/index.qmd) the problems caused by the FHS, and the gymnastics required to work around its limitations. Nix simply sidesteps these problems.

Virtual environments go some way to resolve these problems. Instead of installing packages system-wide, it installs them in a hidden subdirectory. When the virtual environment is active, all relevant environment variables are set to point to these local packages. This way there are no version conflicts between different projects on the same machine. But many problems still remain. Firstly, it doesn't solve the problem of version conflicts among packages within the project itself. Even with an accompanying `requirements.txt`, there is no guarantee that someone else will get the exact same libraries as were used in the original project.

Nix works very differently. Everything in Nix gets placed in a single `/nix/store` directory. Nix prepends the hash value of the package/library (called derivations) to the filenames, ensuring no collisions between different versions of any particular library. Nix defines a graph of dependencies for each package, and installs all requirements, not relying on shared libraries (although it does use hard links to reduce storage requirements).

Below, I provide an example of a flake for Python. By placing this file in a directory and running `nix develop`, you will have Jupyter Lab, VS Code with relevant extensions, and some basic data science libraries. To "install" more packages, just add them to the list and run `nix develop` again. Even better, install [direnv](https://direnv.net/docs/installation.html), and the environment will automatically load when you enter the directory and unload when you leave it. 

A typical environment for Data Science projects involves many inter-dependent libraries. Different projects may use different versions of the same library, leading to potential conflict on a given computer. In order to solve this problem, Python uses *virtual environments* to install the necessary packages in an environment isolated from the rest of the system.

Package management in Python is not straight-forward.

While R libraries have proven significantly less problematic historically, backward-compatibility is not guaranteed across major releases. And there is still the question of portability.

Nix can be installed on Linux, Mac, or Windows with WSL. Official installation instructions can be found [here](https://nixos.org/download/), but I recommend using [Zero to Nix](https://zero-to-nix.com/start/install/) to install Nix because it will configure the flakes feature for you. Installation boils down to running a simple command.


```flake.nix
{
  description = "Python Data Science";
  inputs = {
    nixpkgs = {
      url = "github:nixos/nixpkgs/nixos-unstable";
    };
    flake-utils = {
      url = "github:numtide/flake-utils";
    };
  };
  outputs = { nixpkgs, flake-utils, ... }: flake-utils.lib.eachDefaultSystem (system:
    let
      pkgs = import nixpkgs {
        inherit system;
        config.allowUnfree = true;
      };
      myvscode = pkgs.vscode-with-extensions.override {
        vscodeExtensions = (with pkgs.vscode-extensions; [
        equinusocio.vsc-material-theme
        equinusocio.vsc-material-theme-icons
        vscodevim.vim
        ms-python.python
        ms-python.vscode-pylance
        ms-toolsai.jupyter
        ms-toolsai.jupyter-renderers
        ]);
      };
    in {
      devShell = pkgs.mkShell {
        name = "python-venv";
        venvDir = "./.venv";
        buildInputs = with pkgs; [
          tmux
          myvscode
          (python3.withPackages(ps: with ps; [
            ipython
            pip
            jupyter
            widgetsnbextension
            jupyter-nbextensions-configurator
            jedi-language-server
            ipywidgets
            mypy
            notebook
            pandas
            numpy
            matplotlib
            seaborn
          ]))
        ];
        postVenvCreation = ''
          unset SOURCE_DATE_EPOCH
          pip install -r requirements.txt
        '';

        shellHook = ''
            # export BROWSER=brave
            # Tells pip to put packages into $PIP_PREFIX instead of the usual locations.
            export PIP_PREFIX=$(pwd)/_build/pip_packages
            export PYTHONPATH="$PIP_PREFIX/${pkgs.python3.sitePackages}:$PYTHONPATH"
            export PATH="$PIP_PREFIX/bin:$PATH"
            unset SOURCE_DATE_EPOCH
            # jupyter lab  # uncomment to automatically launch jupyter
        '';

        postShellHook = ''
          # allow pip to install wheels
          unset SOURCE_DATE_EPOCH
        '';
      };
    }
  );
}

```

