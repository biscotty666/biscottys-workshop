{
  "hash": "4573d3edbe100f282a15d5d6ff0f6871",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"GPS Mapping with R\"\ndescription: \"A Comparison with Python\"\noutput: \n  html_document:\n    keep_md: true\n    self_contained: true\ndate: 2025-03-30\ncategories: [GIS, R, Python, Data Science]\nexecute:\n  cache: true\ndraft: false\n---\n\n\n\n\n\nI recently published a series of articles on analyzing GPS data from personal sport tracking software using Python. I've started using R again lately and, while I like Python, I really like R. R is not a general-purpose language like Python, and is therefore far less commonly studied. It was mission-built for this type of work, and, as is often the case with custom-built tools, it is powerful, comfortable, and, frankly, fun to work with. I thought it might be interesting to compare the process in Python described in the [previous articles](../python-gpx-mapping/gpx-gps-data/index.qmd) with the process in R.\n\n## Libraries\n\nPython data frames are built on the `pandas` and `numpy` libraries, with `matplotlib` as the primary plotting tool. Data frames and vector processing are native to R. The `dplyr` library provides convenience functions for manipulating data. The amazing `gplot2` provides the functionality of `matplotlib` and `seaborn` and more, with simple syntax. The `sf` package, which stands for *Simple Features*, provides the geometry and geospatial functionality which `geopandas` and `shapely` do in Python. I'll use `ggspatial` here for basemap tiles where I used `contextily` in Python, and I'll add `patchwork` for convenient side-by-side display.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gpx)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggspatial)\nlibrary(patchwork)\n```\n:::\n\n\n\n## Syntax\n\nA few notes about syntax to start off: R uses the `<-` arrow for assignment, but accepts `=` as well. Data frame slicing uses the same `[row,column]` approach with explicit or boolean values. Unlike `pandas`, which distinguishes between `df.loc` and `df.iloc`, in R you can slice using numeric indices or strings without distinction. On a similar topic, R uses one-indexing, but is inclusive of the end, so `df[1:2]` in R is equivalent to Python's `df.iloc[:2]`, or more explicitly `df.iloc[0:2]`, and the second element is directly accessed with `df[2]` instead of `df.iloc[1]`. \n\nThere's an important twist to this which will catch you multiple times. Even though the syntax is `[row,column]`, if you supply only one numeric index, without a comma, it will be interpreted as a column index. So `df[1]` gets the first column, while `df[1, ]` gets the first row.\n\nThe main syntactical difference is R's extensive use of piping, using the pipe operator `|>`, sometimes written as `%>%`. This looks similar to accessing a series  of an object's methods through a chain of `.`s in Python, but it isn't. The pipe in R works like the pipe in a Linux shell, simply passing the output of one function to the next function as its first argument. This is one of my personal favorite aspects of working in R, since it allows for natural expression of a series of steps which constitue a workflow. `ggplot2` takes a similar _syntactical_ approach, layering elements of the plot by chaining using the `+` operator.\n\n## Loading the data\n\nLet's get started. With Python, we needed to parse the raw `gpx` data, which is in an XML format, to a CSV formatted file, which could then be imported into a `pandas` data frame, and then turned that into a `geopandas` data frame. I used `beautifulsoup` to do so. R, fortunately, has a `gpx` library that allows us to go straight from `gpx` into a data frame. Let's see what that looks like. The `str()` command will let us know what's inside.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrek_data <- read_gpx(\"data/b3/Workout-2024-09-06-16-29-37.gpx\")\nstr(trek_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ routes   :List of 1\n  ..$ :'data.frame':\t0 obs. of  4 variables:\n  .. ..$ Elevation: logi(0) \n  .. ..$ Time     : logi(0) \n  .. ..$ Latitude : logi(0) \n  .. ..$ Longitude: logi(0) \n $ tracks   :List of 1\n  ..$ River Vale:'data.frame':\t137 obs. of  6 variables:\n  .. ..$ Elevation : num [1:137] -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 ...\n  .. ..$ Time      : POSIXct[1:137], format: \"2024-09-06 16:29:37\" \"2024-09-06 16:29:37\" ...\n  .. ..$ Latitude  : num [1:137] 41 41 41 41 41 ...\n  .. ..$ Longitude : num [1:137] -74 -74 -74 -74 -74 ...\n  .. ..$ extensions: logi [1:137] NA NA NA NA NA NA ...\n  .. ..$ Segment ID: int [1:137] 1 1 1 1 1 1 1 1 1 1 ...\n $ waypoints:List of 1\n  ..$ :'data.frame':\t0 obs. of  4 variables:\n  .. ..$ Elevation: logi(0) \n  .. ..$ Time     : logi(0) \n  .. ..$ Latitude : logi(0) \n  .. ..$ Longitude: logi(0) \n```\n\n\n:::\n:::\n\n\n\nThe result is not a data frame, but a list of lists. The second one, called tracks, is the only one with observations, so we can start with that. Don't forget that R does not zero-index lists, so we use `2` not `1`, and extract it with double square brackets.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrek_tracks <- trek_data[[2]]\nstr(trek_tracks)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ River Vale:'data.frame':\t137 obs. of  6 variables:\n  ..$ Elevation : num [1:137] -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 ...\n  ..$ Time      : POSIXct[1:137], format: \"2024-09-06 16:29:37\" \"2024-09-06 16:29:37\" ...\n  ..$ Latitude  : num [1:137] 41 41 41 41 41 ...\n  ..$ Longitude : num [1:137] -74 -74 -74 -74 -74 ...\n  ..$ extensions: logi [1:137] NA NA NA NA NA NA ...\n  ..$ Segment ID: int [1:137] 1 1 1 1 1 1 1 1 1 1 ...\n```\n\n\n:::\n:::\n\n\n\nThis gets us closer, now we have list of one. Let's pull that out and display the first two rows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrek <- trek_tracks[[1]]\ntrek[1:2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Elevation                Time Latitude Longitude extensions Segment ID\n1        -4 2024-09-06 16:29:37 41.01128  -74.0101         NA          1\n2        -4 2024-09-06 16:29:37 41.01128  -74.0101         NA          1\n```\n\n\n:::\n:::\n\n\n\nNote the comma, which is very important. If only one value is supplied, it chooses columns instead of rows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(trek[1:2], 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Elevation                Time\n1        -4 2024-09-06 16:29:37\n2        -4 2024-09-06 16:29:37\n```\n\n\n:::\n:::\n\n\n\nAnd the final frame looks like:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(trek)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t137 obs. of  6 variables:\n $ Elevation : num  -4 -4 -4 -4 -4 -4 -4 -4 -4 -4 ...\n $ Time      : POSIXct, format: \"2024-09-06 16:29:37\" \"2024-09-06 16:29:37\" ...\n $ Latitude  : num  41 41 41 41 41 ...\n $ Longitude : num  -74 -74 -74 -74 -74 ...\n $ extensions: logi  NA NA NA NA NA NA ...\n $ Segment ID: int  1 1 1 1 1 1 1 1 1 1 ...\n```\n\n\n:::\n:::\n\n\n\n## Importing a collection of treks\n\nNow that I know \"where\" the information is, I can go ahead and import a series of files and combine them into a single data frame. As I did with Python, I will assign a unique identifier to each trek, and then combine them. The R equivalent of `df.append` in `pandas` is the aptly-named `bind_rows()` from the `dplyr` library.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles <- list.files(path = \"data/b3/\", \n                    pattern = \"\\\\.gpx$\",\n                    full.names = TRUE)\ndata_list <- list()\ni <- 1\nfor (file in files) {\n  data <- read_gpx(file)[[2]][[1]]\n  data$id = i\n  i <- i + 1\n  data_list[[file]] <- data\n}\ntracks_df <- dplyr::bind_rows(data_list)\nstr(tracks_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3044 obs. of  7 variables:\n $ Elevation : num  79 79 77 76 75 74 72 71 70 70 ...\n $ Time      : POSIXct, format: \"2024-09-05 15:25:13\" \"2024-09-05 15:25:13\" ...\n $ Latitude  : num  41 41 41 41 41 ...\n $ Longitude : num  -74.1 -74.1 -74.1 -74.1 -74.1 ...\n $ extensions: logi  NA NA NA NA NA NA ...\n $ Segment ID: int  1 1 1 1 1 1 1 1 1 1 ...\n $ id        : num  1 1 1 1 1 1 1 1 1 1 ...\n```\n\n\n:::\n:::\n\n\n\nNote the use of `$` to access the columns. An alternate syntax, `data['id']` is available for column names with spaces. This is like `pandas` use of the `.` operator.\n\n## Data frame to geo-data\n\nIn Python, we turned this into a geo-enabled data frame with:\n\n```{{python}}\ntrek_gdf = gpd.GeoDataFrame( \n    trek_df, \n    geometry=gpd.points_from_xy(x=trek_df.Lon, y=trek_df.Lat)\n).set_crs(4269)\ntrek_gdf.info()\n```\n\nR uses the `sf::st_as_sf()` for this purpose, with much less verbose syntax.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreks <- tracks_df |> \n  st_as_sf(coords = c(\"Longitude\",\"Latitude\"),\n           crs = 4326)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(treks)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClasses 'sf' and 'data.frame':\t3044 obs. of  6 variables:\n $ Elevation : num  79 79 77 76 75 74 72 71 70 70 ...\n $ Time      : POSIXct, format: \"2024-09-05 15:25:13\" \"2024-09-05 15:25:13\" ...\n $ extensions: logi  NA NA NA NA NA NA ...\n $ Segment ID: int  1 1 1 1 1 1 1 1 1 1 ...\n $ id        : num  1 1 1 1 1 1 1 1 1 1 ...\n $ geometry  :sfc_POINT of length 3044; first list element:  'XY' num  -74.1 41\n - attr(*, \"sf_column\")= chr \"geometry\"\n - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA\n  ..- attr(*, \"names\")= chr [1:5] \"Elevation\" \"Time\" \"extensions\" \"Segment ID\" ...\n```\n\n\n:::\n:::\n\n\n\nAs you can see, we now have a `geometry` column and the `Time` column was assigned the appropriate type, which we had to do as an additional step in Python. I'll grab the first trek, then plot it with `ggplot`. Using `ggplot` entails adding elements one by one.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrek <- treks[treks$id == 1,]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = trek) +\n  ggspatial::annotation_map_tile(      \n    type = \"osm\",\n    cachedir = \"maps/\",\n    zoomin = -1) +\n  geom_sf(aes(color = Elevation)) +\n  scale_color_viridis_c() +\n  theme_void() +\n  labs(\n    title = paste(\"Elevation Profile: Park Ridge\", as.Date(trek[1,]$Time)),\n    caption = \"Tiles © OpenStreetMap (ODBL license)\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\nIn this case, we pass the data frame (actually an `sf` object) to `ggplot`, then layer on the basemap and the actual points using `geom_sf`, passing it the column we want to color using the `aes()` funtion. \"aes\" is short for aesthetics, and it is where you specify columns to be used for that element. The details of this vary depending on the geometry. `theme_void()` removes axis ticks, and the rest should be self-explanatory.\n\nWe still must change the coordinate system to get appropriate distances. In R, this is \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrek_proj <- trek |> st_transform(crs = 32113)\n```\n:::\n\n\nIn Python, we did\n\n```{{python}}\ntrek_proj = trek_gdf.to_crs(32111)\n```\nWhile the syntax looks similar, Python is accessing a method of the `trek` object, while R is simply passing the output of one function to another.\n\n## Elevations\n\nI won't move beyond points until the next article, but in the first Python one I did calculate the distance, so to be fair I will do so here. I'll explain the code later, but it is a good example of piping in R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance <- trek |> \n  st_transform(crs = 32113) |> \n  dplyr::summarise(do_union = F) |> \n  st_cast(\"LINESTRING\") |> \n  st_length()\nprint(paste(\"Total distance\", round(distance/1000, digits = 1), \"kilometers\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Total distance 7.7 kilometers\"\n```\n\n\n:::\n:::\n\n\n\nLet's see the other basic information. I will put it in a data frame for a nice printout.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\n  \"Elevation\" = c(\"Maximum\",\n             \"Minimum\",\n             \"Average\",\n             \"Initial\",\n             \"Final\"),\n  \"Meters\" = c(max(trek$Elevation),\n               min(trek$Elevation),\n               round(mean(trek$Elevation)),\n               trek[1,]$Elevation,\n               trek[length(trek),]$Elevation)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Elevation Meters\n1   Maximum     81\n2   Minimum     11\n3   Average     45\n4   Initial     79\n5     Final     74\n```\n\n\n:::\n:::\n\n\nThe `c()` function is used to create a vector (not a list), so I specify each column name and assign it a vector with data, ensuring that each vector has the same length, of course. Note how I access the last row of `trek`. There are multiple ways of doing this in R, but sadly negative indexing is not one. This is the most efficient. I will say that I miss Python's f-string, especially with literals (`f\"\"\" \"\"\"`).  \n\nNow we can use `ggplot` for a line chart of the elevation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(trek, aes(x = Time, y = Elevation)) +\n  geom_line() +\n  ggtitle(paste(\"Elevation Profile for Park Ridge Walk on\", as.Date(trek[1,]$Time)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nAnd here are the smoothed profiles using two different methods, and display them side by side with the `patchwork` library.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\ngam_plot <- ggplot(trek, aes(x = Time, y = Elevation)) +\n  geom_line() +\n  geom_smooth(method = \"gam\") +\n  ggtitle(paste(\"NJ (gam smoothing)\", as.Date(trek[1,]$Time)))\n\nloess_plot <- ggplot(trek, aes(x = Time, y = Elevation)) +\n  geom_line() +\n  geom_smooth(method = \"loess\") +\n  ggtitle(paste(\"NJ (loess smoothing)\", as.Date(trek[1,]$Time)))\n\ngam_plot | loess_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n`ggplot2`'s approach of adding layers makes code clear and easy to write, and does not have the odd `fig, ax` mechanism which can be confusing.\n\n## Next steps\n\nI hope you enjoyed this exercise, no pun intended. The code for this is on my websites [GitHub repository](https://github/biscotty666/biscottys-workshop). I'll come out with part 2 soon. Happy coding!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}